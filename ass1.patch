From 47f1515086ea8007232ba3d1ec1be661689cc67e Mon Sep 17 00:00:00 2001
From: Itay Dressler <itaydr@mobli.com>
Date: Sat, 11 Apr 2015 23:54:43 +0300
Subject: [PATCH] Added files after assaf's  changes.

---
 GLOBAL_TEST.c         |   63 ++
 Makefile              |   14 +-
 cat.c                 |    8 +-
 defs.h                |   11 +-
 echo.c                |    4 +-
 exec.c                |   23 +-
 exec_copy_exit.S      |   15 +
 fg.c                  |   20 +
 forktest.c            |   14 +-
 grep.c                |    8 +-
 init.c                |    7 +-
 job.h                 |    9 +
 kill.c                |    4 +-
 ln.c                  |    4 +-
 ls.c                  |    4 +-
 mkdir.c               |    4 +-
 param.h               |    1 +
 proc.c                |  729 +++++++++++++++++++-
 proc.h                |   19 +
 read.c                |   16 +
 rm.c                  |    4 +-
 sanity.c              |   60 ++
 scheduler_CFS.c       |   52 ++
 scheduler_DEFAULT.c   |   37 ++
 scheduler_FCFS.c      |   52 ++
 scheduler_FRR.c       |   52 ++
 scheduler_cir_queue.c |   81 +++
 scheduler_cir_queue.h |   13 +
 sh.c                  |   71 +-
 shced                 |   11 +
 spinlock.c            |    4 +-
 stat.h                |    1 +
 stressfs.c            |    4 +-
 syscall.c             |   12 +
 syscall.h             |    7 +
 sysfile.c             |    7 +
 sysproc.c             |   81 ++-
 t1.c                  |   18 +
 t2.c                  |   20 +
 t3.c                  |   20 +
 trap.c                |   23 +-
 types.h               |   19 +
 user.h                |   10 +-
 usertests.c           | 1757 -------------------------------------------------
 usys.S                |    6 +
 wc.c                  |    8 +-
 zombie.c              |    2 +-
 47 files changed, 1570 insertions(+), 1839 deletions(-)
 create mode 100644 GLOBAL_TEST.c
 create mode 100644 exec_copy_exit.S
 create mode 100644 fg.c
 create mode 100644 job.h
 create mode 100644 read.c
 create mode 100644 sanity.c
 create mode 100644 scheduler_CFS.c
 create mode 100644 scheduler_DEFAULT.c
 create mode 100644 scheduler_FCFS.c
 create mode 100644 scheduler_FRR.c
 create mode 100644 scheduler_cir_queue.c
 create mode 100644 scheduler_cir_queue.h
 create mode 100644 shced
 create mode 100644 t1.c
 create mode 100644 t2.c
 create mode 100644 t3.c

diff --git a/GLOBAL_TEST.c b/GLOBAL_TEST.c
new file mode 100644
index 0000000..2eae12a
--- /dev/null
+++ b/GLOBAL_TEST.c
@@ -0,0 +1,63 @@
+#include "types.h"
+#include "user.h"
+
+void print_nonsense(void){
+
+  printf(1, "a\n");
+}
+
+int
+main(int argc, char *argv[])
+{
+	int status, wtime, rtime, iotime;						//uncomment to check runnning time (1)
+	
+	//for (;;)
+	//printf(2, "pid - %d\n", getpid());
+	
+	set_priority(P_LOW);
+	
+	wait_stat(&status, &wtime, &rtime, &iotime);
+	printf(2, "ready (runnable) time is: %d\n", wtime);
+	printf(2, "running time is: %d\n", rtime);
+	printf(2, "sleeping (waiting for io) time is: %d\n", iotime);
+	exit(0);
+}
+
+/*
+
+#include "types.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+int pid;
+int w,r,io;
+int npid = 0;
+npid = npid;
+
+if (!(pid = fork()))
+{
+  printf(1, "intermediate child\n");
+  if (!(pid = fork())) {
+    printf(1,"child getting to sleep 500\n");
+    sleep(500); 
+    printf(1,"child getting out from sleep 500, exit (123)\n");
+  } else {
+    printf(1, "intermediate child is going to die\n");
+  }
+
+  
+  exit(123);
+}
+else
+{
+  
+   printf(1, "parent waiting for child %d\n", pid);
+   wait_stat(&w,&r,&io);
+   printf(1, "Stats: w:%d r:%d io:%d\n", w,r,io);
+}
+exit(4444);
+}
+
+*/
\ No newline at end of file
diff --git a/Makefile b/Makefile
index c94c71d..f4dcb1a 100644
--- a/Makefile
+++ b/Makefile
@@ -27,6 +27,7 @@ OBJS = \
 	uart.o\
 	vectors.o\
 	vm.o\
+	exec_copy_exit.o\
 
 # Cross-compiling (e.g., on Mac OS X)
 # TOOLPREFIX = i386-jos-elf
@@ -69,13 +70,17 @@ QEMU = $(shell if which qemu > /dev/null; \
 	echo "***" 1>&2; exit 1)
 endif
 
+ifndef SCHEDFLAG
+SCHEDFLAG = DEFAULT
+endif
+
 CC = $(TOOLPREFIX)gcc
 AS = $(TOOLPREFIX)gas
 LD = $(TOOLPREFIX)ld
 OBJCOPY = $(TOOLPREFIX)objcopy
 OBJDUMP = $(TOOLPREFIX)objdump
 #CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
-CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -fvar-tracking -fvar-tracking-assignments -O0 -g -Wall -MD -gdwarf-2 -m32 -Werror -fno-omit-frame-pointer
+CFLAGS = -D SCHEDFLAG=$(SCHEDFLAG) -fno-pic -static -fno-builtin -fno-strict-aliasing -fvar-tracking -fvar-tracking-assignments -O0 -g -Wall -MD -gdwarf-2 -m32 -Werror -fno-omit-frame-pointer
 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
 ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
 # FreeBSD ld wants ``elf_i386_fbsd''
@@ -172,6 +177,13 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+	_GLOBAL_TEST\
+	_read\
+	_fg\
+	_t1\
+	_t2\
+	_t3\
+	_sanity\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
diff --git a/cat.c b/cat.c
index 2b2dcc7..a0fc2d7 100644
--- a/cat.c
+++ b/cat.c
@@ -13,7 +13,7 @@ cat(int fd)
     write(1, buf, n);
   if(n < 0){
     printf(1, "cat: read error\n");
-    exit();
+    exit(EXIT_STATUS_ERR);
   }
 }
 
@@ -24,16 +24,16 @@ main(int argc, char *argv[])
 
   if(argc <= 1){
     cat(0);
-    exit();
+    exit(EXIT_STATUS_ERR);
   }
 
   for(i = 1; i < argc; i++){
     if((fd = open(argv[i], 0)) < 0){
       printf(1, "cat: cannot open %s\n", argv[i]);
-      exit();
+      exit(EXIT_STATUS_ERR);
     }
     cat(fd);
     close(fd);
   }
-  exit();
+  exit(EXIT_STATUS_OK);
 }
diff --git a/defs.h b/defs.h
index 43431e3..14782f8 100644
--- a/defs.h
+++ b/defs.h
@@ -105,8 +105,9 @@ int             pipewrite(struct pipe*, char*, int);
 //PAGEBREAK: 16
 // proc.c
 struct proc*    copyproc(struct proc*);
-void            exit(void);
+void            exit(int status);
 int             fork(void);
+int 		forkjob(char *command);
 int             growproc(int);
 int             kill(int);
 void            pinit(void);
@@ -115,9 +116,15 @@ void            scheduler(void) __attribute__((noreturn));
 void            sched(void);
 void            sleep(void*, struct spinlock*);
 void            userinit(void);
-int             wait(void);
+int             wait(int *status);
+int 		waitpid(int pid, int *status, int options);
 void            wakeup(void*);
 void            yield(void);
+int 		jobs();
+int             fg(int jid);
+void 		update_counters();
+int 		wait_stat(int *status, int *wtime, int *rtime, int *iotime);
+int 		set_priority(int priority);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
diff --git a/echo.c b/echo.c
index 806dee0..a74a29c 100644
--- a/echo.c
+++ b/echo.c
@@ -9,5 +9,7 @@ main(int argc, char *argv[])
 
   for(i = 1; i < argc; i++)
     printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
-  exit();
+  exit(EXIT_STATUS_OK);
+    
+   // return -3;
 }
diff --git a/exec.c b/exec.c
index 8dbbdb6..3edcb1b 100644
--- a/exec.c
+++ b/exec.c
@@ -7,11 +7,14 @@
 #include "x86.h"
 #include "elf.h"
 
+extern int EXEC_COPY_EXIT(void);
+extern int EXEC_COPY_EXIT_END(void);
+
 int
 exec(char *path, char **argv)
 {
   char *s, *last;
-  int i, off;
+  int i, off, exec_copy_exit_diff;
   uint argc, sz, sp, ustack[3+MAXARG+1];
   struct elfhdr elf;
   struct inode *ip;
@@ -71,8 +74,20 @@ exec(char *path, char **argv)
     ustack[3+argc] = sp;
   }
   ustack[3+argc] = 0;
-
-  ustack[0] = 0xffffffff;  // fake return PC
+  
+  
+  // @itay - calculate the size to copy, copy and save the address at sz.
+  exec_copy_exit_diff	= EXEC_COPY_EXIT_END - EXEC_COPY_EXIT;
+  sp = ( sp - exec_copy_exit_diff );// & ~3;
+  copyout(pgdir,sp,EXEC_COPY_EXIT,exec_copy_exit_diff);
+  ustack[0] = sp;//0xffffffff;  // fake return PC (sp will make EXIT call)
+  // End
+  
+//  cprintf(2, "we wanna junp to: %d ", sp);
+//  for ( i = 0 ; i < 8 ; ++i) {
+//    cprintf(2, " i:    %d  \n", i, ustack[i]);
+//  }
+   
   ustack[1] = argc;
   ustack[2] = sp - (argc+1)*4;  // argv pointer
 
@@ -85,7 +100,7 @@ exec(char *path, char **argv)
     if(*s == '/')
       last = s+1;
   safestrcpy(proc->name, last, sizeof(proc->name));
-
+ 
   // Commit to the user image.
   oldpgdir = proc->pgdir;
   proc->pgdir = pgdir;
diff --git a/exec_copy_exit.S b/exec_copy_exit.S
new file mode 100644
index 0000000..082116f
--- /dev/null
+++ b/exec_copy_exit.S
@@ -0,0 +1,15 @@
+#include "asm.h"
+#include "memlayout.h"
+#include "syscall.h"
+#include "traps.h"
+
+.globl EXEC_COPY_EXIT
+EXEC_COPY_EXIT:
+  pushl %eax
+  pushl %eax
+  movl $SYS_exit, %eax
+  int $T_SYSCALL
+  ret
+  
+.globl EXEC_COPY_EXIT_END
+EXEC_COPY_EXIT_END:
diff --git a/fg.c b/fg.c
new file mode 100644
index 0000000..0e78977
--- /dev/null
+++ b/fg.c
@@ -0,0 +1,20 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int 
+main(int argc, char *argv[])
+{
+
+  if (argc == 1) {
+    fg(NULL); 
+  }
+  else if (argc == 2){
+    fg(atoi(argv[1]));
+  }
+  else {
+    printf(1, "Too much arguments for FG."); 
+  }
+  
+  exit(EXIT_STATUS_OK);
+}
\ No newline at end of file
diff --git a/forktest.c b/forktest.c
index bb286e6..846eee0 100644
--- a/forktest.c
+++ b/forktest.c
@@ -25,24 +25,24 @@ forktest(void)
     if(pid < 0)
       break;
     if(pid == 0)
-      exit();
+      exit(EXIT_STATUS_OK);
   }
   
   if(n == N){
     printf(1, "fork claimed to work N times!\n", N);
-    exit();
+    exit(EXIT_STATUS_OK);
   }
   
   for(; n > 0; n--){
-    if(wait() < 0){
+    if(wait(NULL) < 0){
       printf(1, "wait stopped early\n");
-      exit();
+      exit(EXIT_STATUS_ERR);
     }
   }
   
-  if(wait() != -1){
+  if(wait(NULL) != -1){
     printf(1, "wait got too many\n");
-    exit();
+    exit(EXIT_STATUS_ERR);
   }
   
   printf(1, "fork test OK\n");
@@ -52,5 +52,5 @@ int
 main(void)
 {
   forktest();
-  exit();
+  exit(EXIT_STATUS_OK);
 }
diff --git a/grep.c b/grep.c
index 2fbf5b6..698232b 100644
--- a/grep.c
+++ b/grep.c
@@ -42,24 +42,24 @@ main(int argc, char *argv[])
   
   if(argc <= 1){
     printf(2, "usage: grep pattern [file ...]\n");
-    exit();
+    exit(EXIT_STATUS_ERR);
   }
   pattern = argv[1];
   
   if(argc <= 2){
     grep(pattern, 0);
-    exit();
+    exit(EXIT_STATUS_OK);
   }
 
   for(i = 2; i < argc; i++){
     if((fd = open(argv[i], 0)) < 0){
       printf(1, "grep: cannot open %s\n", argv[i]);
-      exit();
+      exit(EXIT_STATUS_ERR);
     }
     grep(pattern, fd);
     close(fd);
   }
-  exit();
+  exit(EXIT_STATUS_OK);
 }
 
 // Regexp matcher from Kernighan & Pike,
diff --git a/init.c b/init.c
index 046b551..fb77a03 100644
--- a/init.c
+++ b/init.c
@@ -24,14 +24,15 @@ main(void)
     pid = fork();
     if(pid < 0){
       printf(1, "init: fork failed\n");
-      exit();
+      exit(EXIT_STATUS_ERR);
     }
     if(pid == 0){
       exec("sh", argv);
       printf(1, "init: exec sh failed\n");
-      exit();
+      exit(EXIT_STATUS_ERR);
     }
-    while((wpid=wait()) >= 0 && wpid != pid)
+
+    while((wpid=wait(NULL)) >= 0 && wpid != pid)
       printf(1, "zombie!\n");
   }
 }
diff --git a/job.h b/job.h
new file mode 100644
index 0000000..20dba22
--- /dev/null
+++ b/job.h
@@ -0,0 +1,9 @@
+// Job
+
+enum jobstate { JOB_S_UNUSED, JOB_S_EMBRYO };
+
+struct job {
+  char commandName[32];   
+  int jid;
+  enum jobstate state;
+};
\ No newline at end of file
diff --git a/kill.c b/kill.c
index 5e60113..61b2b93 100644
--- a/kill.c
+++ b/kill.c
@@ -9,9 +9,9 @@ main(int argc, char **argv)
 
   if(argc < 1){
     printf(2, "usage: kill pid...\n");
-    exit();
+    exit(EXIT_STATUS_ERR);
   }
   for(i=1; i<argc; i++)
     kill(atoi(argv[i]));
-  exit();
+  exit(EXIT_STATUS_OK);
 }
diff --git a/ln.c b/ln.c
index cf8a64e..bff0d9e 100644
--- a/ln.c
+++ b/ln.c
@@ -7,9 +7,9 @@ main(int argc, char *argv[])
 {
   if(argc != 3){
     printf(2, "Usage: ln old new\n");
-    exit();
+    exit(EXIT_STATUS_ERR);
   }
   if(link(argv[1], argv[2]) < 0)
     printf(2, "link %s %s: failed\n", argv[1], argv[2]);
-  exit();
+  exit(EXIT_STATUS_OK);
 }
diff --git a/ls.c b/ls.c
index b6ddd7f..52d9088 100644
--- a/ls.c
+++ b/ls.c
@@ -77,9 +77,9 @@ main(int argc, char *argv[])
 
   if(argc < 2){
     ls(".");
-    exit();
+    exit(EXIT_STATUS_OK);
   }
   for(i=1; i<argc; i++)
     ls(argv[i]);
-  exit();
+  exit(EXIT_STATUS_OK);
 }
diff --git a/mkdir.c b/mkdir.c
index 6e4c954..35921b3 100644
--- a/mkdir.c
+++ b/mkdir.c
@@ -9,7 +9,7 @@ main(int argc, char *argv[])
 
   if(argc < 2){
     printf(2, "Usage: mkdir files...\n");
-    exit();
+    exit(EXIT_STATUS_ERR);
   }
 
   for(i = 1; i < argc; i++){
@@ -19,5 +19,5 @@ main(int argc, char *argv[])
     }
   }
 
-  exit();
+  exit(EXIT_STATUS_OK);
 }
diff --git a/param.h b/param.h
index 8e007ca..8431958 100644
--- a/param.h
+++ b/param.h
@@ -10,4 +10,5 @@
 #define MAXOPBLOCKS  10  // max # of blocks any FS op writes
 #define LOGSIZE      (MAXOPBLOCKS*3)  // max data sectors in on-disk log
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
+#define QUANTA		5
 
diff --git a/proc.c b/proc.c
index a642f5a..811a55f 100644
--- a/proc.c
+++ b/proc.c
@@ -7,23 +7,70 @@
 #include "proc.h"
 #include "spinlock.h"
 
+#define SHELL_ID	2
+
+#define DEFAULT 1
+#define FRR 2
+#define FCFS 3
+#define CFS 4
+
+//------- helper funcs -----------
+int get_current_ticks(void);
+void update_counters();
+int shared_wait(int *status ,int *wtime, int *rtime, int *iotime);
+void on_state_set_to_runnable(struct proc *cur_proc);
+void on_state_set_to_sleeping(struct proc *cur_proc);
+void on_state_set_to_zombi(struct proc *cur_proc);
+void on_state_set_to_running(struct proc *cur_proc);
+void sched_q_enqueue(int pid);
+int  sched_q_dequeue(void);
+void sched_q_display(void);
+int  sched_q_peek(void);
+/*
+void remove_from_sched_array(struct proc *cur_proc);
+void add_to_sched_array(struct proc *cur_proc);
+int  sched_array_get_min_vruntime_pid(void);
+void sched_array_display_valid_entries(void);
+*/
+
+int front = -1;
+int rear  = -1;
+
+// Processes table
 struct {
   struct spinlock lock;
   struct proc proc[NPROC];
 } ptable;
 
+
+// Jobs table
+struct {
+  struct spinlock lock;
+  struct job jobs[NPROC];
+} jtable;
+
+// scheduler queue
+struct {
+  //struct spinlock lock;
+  struct runnable_queue_entry queue[NPROC];
+} scheduler_queue;
+
+
 static struct proc *initproc;
 
 int nextpid = 1;
+int nextjid = 1;
 extern void forkret(void);
 extern void trapret(void);
 
+int cleanJobIfNeeded(void);
 static void wakeup1(void *chan);
 
 void
 pinit(void)
 {
   initlock(&ptable.lock, "ptable");
+  initlock(&jtable.lock, "jtable");
 }
 
 //PAGEBREAK: 32
@@ -46,6 +93,7 @@ allocproc(void)
 
 found:
   p->state = EMBRYO;
+  p->priority = P_MED;
   p->pid = nextpid++;
   release(&ptable.lock);
 
@@ -73,6 +121,29 @@ found:
   return p;
 }
 
+static struct job*
+allocjob(void)
+{
+  struct job *j;
+  int index = 0;
+  acquire(&jtable.lock);
+  for(j = jtable.jobs; j < &jtable.jobs[NPROC]; j++) {
+    if(j->state == JOB_S_UNUSED) {
+      goto found;
+    }
+    index++;
+  }
+  release(&jtable.lock);
+  return 0;
+
+found:
+  j->state = JOB_S_EMBRYO;
+  j->jid = nextjid++;
+  release(&jtable.lock);
+  
+  return j;
+}
+
 //PAGEBREAK: 32
 // Set up first user process.
 void
@@ -100,6 +171,7 @@ userinit(void)
   p->cwd = namei("/");
 
   p->state = RUNNABLE;
+  on_state_set_to_runnable(p);
 }
 
 // Grow current process's memory by n bytes.
@@ -122,6 +194,25 @@ growproc(int n)
   return 0;
 }
 
+struct job*
+createJob(char *command) {
+  struct job *nj;
+  char *last, *s;
+    
+  // Allocate job.
+  if((nj = allocjob()) == NULL)
+    return NULL;
+  
+  
+  for(last=s=command; *s; s++)
+    if(*s == '/')
+      last = s+1;
+  
+  safestrcpy(nj->commandName, last, sizeof(nj->commandName));
+  
+  return nj;
+}
+
 // Create a new process copying p as the parent.
 // Sets up stack to return as if from system call.
 // Caller must set state of returned proc to RUNNABLE.
@@ -134,7 +225,7 @@ fork(void)
   // Allocate process.
   if((np = allocproc()) == 0)
     return -1;
-
+  
   // Copy process state from p.
   if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
     kfree(np->kstack);
@@ -142,10 +233,76 @@ fork(void)
     np->state = UNUSED;
     return -1;
   }
+  
+  if (proc->job == NULL && proc->pid >= SHELL_ID) {
+      cprintf("Error - Forking new process from a process which don't have a job!.\n");
+  }
+  
+  np->job = proc->job;
+    
   np->sz = proc->sz;
   np->parent = proc;
   *np->tf = *proc->tf;
+  
+  // Clear %eax so that fork returns 0 in the child.
+  np->tf->eax = 0;
+
+  for(i = 0; i < NOFILE; i++)
+    if(proc->ofile[i])
+      np->ofile[i] = filedup(proc->ofile[i]);
+  np->cwd = idup(proc->cwd);
+
+  safestrcpy(np->name, proc->name, sizeof(proc->name));
 
+  pid = np->pid;
+
+  // lock to force the compiler to emit the np->state write last.
+  acquire(&ptable.lock);
+  np->state = RUNNABLE;
+  on_state_set_to_runnable(np);
+  
+  // set initial creation time
+  np->stime	 = 0;
+  np->retime 	 = 0;
+  np->rutime 	 = 0;
+  np->ctime = get_current_ticks();
+  
+  
+  release(&ptable.lock);
+  
+  return pid;
+}
+
+// Same as fork, but creates a new job.
+int
+forkjob(char *command)
+{
+  int i, pid;
+  struct proc *np;
+  struct job *nj;
+
+  // Allocate process.
+  if((np = allocproc()) == 0)
+    return -1;
+  
+  // Copy process state from p.
+  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
+    kfree(np->kstack);
+    np->kstack = 0;
+    np->state = UNUSED;
+    return -1;
+  }
+  
+  // Create a new job.
+  if ((nj = createJob(command)) == NULL) {
+    panic("Failed creating a job");
+  }
+  
+  np->job = nj;
+  np->sz = proc->sz;
+  np->parent = proc;
+  *np->tf = *proc->tf;
+  
   // Clear %eax so that fork returns 0 in the child.
   np->tf->eax = 0;
 
@@ -155,12 +312,20 @@ fork(void)
   np->cwd = idup(proc->cwd);
 
   safestrcpy(np->name, proc->name, sizeof(proc->name));
- 
+
   pid = np->pid;
 
   // lock to force the compiler to emit the np->state write last.
   acquire(&ptable.lock);
   np->state = RUNNABLE;
+  on_state_set_to_runnable(np);
+  
+  // initial creation time
+  np->stime	 = 0;
+  np->retime 	 = 0;
+  np->rutime 	 = 0;
+  np->ctime = get_current_ticks();
+  
   release(&ptable.lock);
   
   return pid;
@@ -170,11 +335,16 @@ fork(void)
 // An exited process remains in the zombie state
 // until its parent calls wait() to find out it exited.
 void
-exit(void)
+exit(int status)
 {
+  //cprintf("enterted: exit, %d\n", status);
   struct proc *p;
   int fd;
-
+  
+  // set termination time
+  proc->ttime = get_current_ticks();
+  
+  
   if(proc == initproc)
     panic("init exiting");
 
@@ -185,6 +355,9 @@ exit(void)
       proc->ofile[fd] = 0;
     }
   }
+  
+  proc->exitStatus = status;
+  cleanJobIfNeeded();
 
   begin_op();
   iput(proc->cwd);
@@ -195,7 +368,8 @@ exit(void)
 
   // Parent might be sleeping in wait().
   wakeup1(proc->parent);
-
+  wakeup1(proc);
+  
   // Pass abandoned children to init.
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
     if(p->parent == proc){
@@ -207,6 +381,7 @@ exit(void)
 
   // Jump into the scheduler, never to return.
   proc->state = ZOMBIE;
+  on_state_set_to_zombi(proc);
   sched();
   panic("zombie exit");
 }
@@ -214,8 +389,18 @@ exit(void)
 // Wait for a child process to exit and return its pid.
 // Return -1 if this process has no children.
 int
-wait(void)
+wait(int *status)
 {
+  return shared_wait(status, NULL, NULL, NULL);
+}
+
+int wait_stat(int *status, int *wtime, int *rtime, int *iotime) {
+  return shared_wait(status, wtime, rtime, iotime); 
+}
+
+
+int shared_wait(int *status ,int *wtime, int *rtime, int *iotime) {
+
   struct proc *p;
   int havekids, pid;
 
@@ -230,6 +415,20 @@ wait(void)
       if(p->state == ZOMBIE){
         // Found one.
         pid = p->pid;
+	
+	if (status != NULL) {
+	   *status = p->exitStatus;
+	} else {
+	  *status = -2;
+	}
+	
+	if (wtime != NULL)
+	  *wtime = p->retime;
+	if (rtime != NULL)
+	  *rtime = p->rutime;
+	if (iotime != NULL)
+	  *iotime = p->stime;
+	
         kfree(p->kstack);
         p->kstack = 0;
         freevm(p->pgdir);
@@ -238,7 +437,16 @@ wait(void)
         p->parent = 0;
         p->name[0] = 0;
         p->killed = 0;
+	p->job = 0;
+	p->ctime = 0;
+	p->ttime = 0;
+	p->retime = 0;
+	p->rutime = 0;
+	p->stime = 0;
+	p->sched_time = 0;
+	p->priority = P_UNDEF;
         release(&ptable.lock);
+	
         return pid;
       }
     }
@@ -251,9 +459,100 @@ wait(void)
 
     // Wait for children to exit.  (See wakeup1 call in proc_exit.)
     sleep(proc, &ptable.lock);  //DOC: wait-sleep
+  }  
+}
+
+
+// if BLOCKING - Wait for a process with id: pid to exit and return its status.
+// if BLOCKING - return its status or -1.
+// Return -1 if this process has no children.
+int 
+waitpid(int pid, int *status, int options)
+{
+  struct proc *p, *foundProc;
+  int is_exists = 0;
+
+  acquire(&ptable.lock);
+  for(;;){
+    // Scan through table looking for zombie children.
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if (p-> pid == pid) {
+	is_exists = 1;
+	foundProc = p;
+	if(p->state == ZOMBIE){
+	  // Found one.
+	  pid = p->pid;
+	
+	  if (status != NULL) {
+	    *status = p->exitStatus;
+	  } else {
+	    *status = -2;
+	  }
+	  
+	  kfree(p->kstack);
+	  p->kstack = 0;
+	  freevm(p->pgdir);
+	  p->state = UNUSED;
+	  p->pid = 0;
+	  p->parent = 0;
+	  p->name[0] = 0;
+	  p->killed = 0;
+	  p->job = 0;
+	  p->ctime = 0;
+	  p->ttime = 0;
+	  p->retime = 0;
+	  p->rutime = 0;
+	  p->stime = 0;
+	  p->sched_time = 0;
+	  p->priority = P_UNDEF;
+	  release(&ptable.lock);
+	  
+	  return pid;
+	}
+	
+	if (options == NON_BLOCKING) {
+	  release(&ptable.lock);
+	  return -1;
+	}
+      }
+    }
+
+    // No point waiting if we don't have any children.
+    if(!is_exists || proc->killed){
+      release(&ptable.lock);
+      return -1;
+    }
+
+    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+    sleep(foundProc, &ptable.lock);  //DOC: wait-sleep
+    foundProc = NULL;is_exists = FALSE;
   }
 }
 
+
+int cleanJobIfNeeded(void) {
+   int jid = proc->job->jid;
+   struct proc *p;
+   struct job *j;
+   
+    for (p = ptable.proc ; p < &ptable.proc[NPROC] ; p++ ) {
+	if (p->pid != proc->pid &&  // If it's not the current process
+	    p->job->jid == jid &&   // Current process and p share the sam job.
+	    p->state != UNUSED) {   // p is still alive.
+	 
+	   return 0;
+	}
+    }
+    
+   // If we reached here we need to kill the job.
+   j = proc->job;
+   j->jid = 0;
+   j->state = JOB_S_UNUSED;
+   j->commandName[0] = NULL;
+   
+   return 1;
+}
+
 //PAGEBREAK: 42
 // Per-CPU process scheduler.
 // Each CPU calls scheduler() after setting itself up.
@@ -262,39 +561,135 @@ wait(void)
 //  - swtch to start running that process
 //  - eventually that process transfers control
 //      via swtch back to the scheduler.
+
+#if SCHEDFLAG == DEFAULT
+  #include "scheduler_DEFAULT.c"
+  
+#elif SCHEDFLAG == FRR
+  #include "scheduler_FRR.c"
+  
+#elif SCHEDFLAG == FCFS
+  #include "scheduler_FCFS.c"
+  
+#elif SCHEDFLAG == CFS
+  #include "scheduler_CFS.c"
+  
+#endif
+
+/*
+void scheduler(void)
+{
+  struct proc *p;
+  
+  struct proc *selected_p = NULL;
+  
+  cprintf("LOADED SCHEDFLAG == FRR\n");
+  
+  for(;;){
+    // Enable interrupts on this processor.
+    sti();
+
+    // Loop over process table looking for process to run.
+    //cprintf("test1111\n");
+    acquire(&ptable.lock);
+    //cprintf("test2222\n");
+    
+    selected_p = NULL;
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->state != RUNNABLE)
+	continue;
+      
+      if (selected_p == NULL) {
+	selected_p = p;
+	continue;
+      }
+
+      if ( selected_p->sched_time > p->sched_time ) {
+	selected_p = p;
+      }
+    }
+
+    
+if (selected_p == NULL) {
+  release(&ptable.lock);
+  continue;
+}
+
+    
+      cprintf("choose to switch to: %d\n", selected_p->pid);
+      // Switch to chosen process.  It is the process's job
+      // to release ptable.lock and then reacquire it
+      // before jumping back to us.
+	    
+      proc = selected_p;
+      switchuvm(selected_p);
+      selected_p->state = RUNNING;
+      on_state_set_to_running(p);
+      swtch(&cpu->scheduler, proc->context);
+      switchkvm();
+
+      // Process is done running for now.
+      // It should have changed its p->state before coming back.
+      proc = 0;
+    
+    
+    //cprintf("LOOP %d !\n", selected_p->pid);
+    selected_p = NULL;
+    release(&ptable.lock);
+  }
+}
+*/
+
+
+/*
 void
 scheduler(void)
 {
   struct proc *p;
-
+  
+  struct proc *selected_p = NULL;
+  selected_p = selected_p;
+  
   for(;;){
     // Enable interrupts on this processor.
     sti();
 
     // Loop over process table looking for process to run.
+    //cprintf("test1111 - acquire scheduler\n");
     acquire(&ptable.lock);
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    //cprintf("test2222\n");
+    
+    //#include "sched.c"
+    selected_p = NULL;for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
       if(p->state != RUNNABLE)
         continue;
-
+	
       // Switch to chosen process.  It is the process's job
       // to release ptable.lock and then reacquire it
       // before jumping back to us.
       proc = p;
       switchuvm(p);
       p->state = RUNNING;
+      on_state_set_to_running(p);
       swtch(&cpu->scheduler, proc->context);
       switchkvm();
 
       // Process is done running for now.
       // It should have changed its p->state before coming back.
       proc = 0;
-    }
+      cprintf("LOOP %d !\n", p->pid);
+}
+
+
+    
+    
+    //cprintf("test1111 - release scheduler\n");
     release(&ptable.lock);
 
   }
 }
 
+*/
 // Enter scheduler.  Must hold only ptable.lock
 // and have changed proc->state.
 void
@@ -319,9 +714,12 @@ sched(void)
 void
 yield(void)
 {
+  //cprintf("test1111 - acquire yield\n");
   acquire(&ptable.lock);  //DOC: yieldlock
   proc->state = RUNNABLE;
+  on_state_set_to_runnable(proc);
   sched();
+  //cprintf("test1111 - release yield\n");
   release(&ptable.lock);
 }
 
@@ -370,6 +768,7 @@ sleep(void *chan, struct spinlock *lk)
   // Go to sleep.
   proc->chan = chan;
   proc->state = SLEEPING;
+  on_state_set_to_sleeping(proc);
   sched();
 
   // Tidy up.
@@ -391,8 +790,11 @@ wakeup1(void *chan)
   struct proc *p;
 
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == SLEEPING && p->chan == chan)
+    if(p->state == SLEEPING && p->chan == chan){
       p->state = RUNNABLE;
+      on_state_set_to_runnable(p);
+    }
+    
 }
 
 // Wake up all processes sleeping on chan.
@@ -417,8 +819,10 @@ kill(int pid)
     if(p->pid == pid){
       p->killed = 1;
       // Wake process from sleep if necessary.
-      if(p->state == SLEEPING)
+      if(p->state == SLEEPING) {
         p->state = RUNNABLE;
+	on_state_set_to_runnable(p);
+      }
       release(&ptable.lock);
       return 0;
     }
@@ -463,3 +867,304 @@ procdump(void)
     cprintf("\n");
   }
 }
+
+int jobs() {
+  
+  struct job *j;
+  struct proc *p;
+  int foundJobs = FALSE, isJobAlive = FALSE, liveJobIndex = 0;
+    
+  for (j = jtable.jobs ; j < &jtable.jobs[NPROC] ; j++ ) {
+    isJobAlive = 0;
+    for (p = ptable.proc ; p < &ptable.proc[NPROC] ; p++ ) {
+      if (p->job->jid == j->jid && 				// If the process belongs to the job.
+	  p->state != UNUSED					// If the process is alive.
+	 ) {		
+	if (isJobAlive == FALSE) {
+	    cprintf("Job %d: %s \n", ++liveJobIndex, j->commandName);
+	}
+	
+	cprintf("%d: %s\n", p->pid, p->name);
+	
+	isJobAlive = TRUE;
+        foundJobs = TRUE;
+      }
+    }
+   }
+  
+  if (foundJobs == FALSE) {
+    cprintf("There are no Jobs\n");
+  }
+    
+  return 1;
+}
+
+int fg(int jid) {
+  
+ struct job *j;
+ struct proc *p;
+ int jobExists = FALSE;
+ 
+ if (jid == NULL) {
+   for (j = jtable.jobs ; j < &jtable.jobs[NPROC] ; j++ )  {
+     if (j->state != JOB_S_UNUSED && proc->job->jid != j->jid) {
+       jid = j->jid; 
+       break;
+     }
+   }
+ }
+ 
+  for (p = ptable.proc ; p < &ptable.proc[NPROC] ; p++ )  {
+    if (p->job->jid == jid) {
+      jobExists = TRUE;
+      waitpid(p->pid, NULL, BLOCKING);
+    }
+  }
+  
+  if (jobExists == FALSE) {
+   cprintf("Could'nt find job - %d\n", jid); 
+  }
+  
+ return 1; 
+}
+
+
+//----------------------------------------- helper functions ---------------
+int get_current_ticks(void)
+{
+  uint xticks;
+  
+  acquire(&tickslock);
+  xticks = ticks;
+  release(&tickslock);
+  return xticks;
+}
+
+void update_counters()
+{
+  struct proc *p;
+  
+  //acquire(&ptable.lock);
+  for (p = ptable.proc ; p < &ptable.proc[NPROC] ; p++ )  {
+    switch(p->state) {
+      case RUNNING:
+	p->rutime +=1;
+	break;
+      case SLEEPING:
+	p->stime +=1;
+	break;
+      case RUNNABLE:
+	p->retime +=1;
+	break;
+      default:
+	//cprintf("ERROR update_counters - state: %d", proc->state);
+	break;
+    };
+    //cprintf("RUN: %d, SLEEP: %d\n", p->rutime, p->stime);
+  }
+  //release(&ptable.lock);
+}
+
+//void update_sched_time_based_on_method(struct proc *cur_proc)
+void on_state_set_to_runnable(struct proc *cur_proc)
+{  
+// cur_proc->sched_time = get_current_ticks();/* - BUGGGGGGGGGGGGGGGGG
+#if SCHEDFLAG == DEFAULT
+#elif SCHEDFLAG == FRR
+  sched_q_enqueue(cur_proc->pid);
+#elif SCHEDFLAG == FCFS
+  sched_q_enqueue(cur_proc->pid);
+#elif SCHEDFLAG == CFS
+  //add_to_sched_array(cur_proc);
+#endif
+  
+  return;
+}
+
+void on_state_set_to_sleeping(struct proc *cur_proc)
+{
+  
+#if SCHEDFLAG == DEFAULT
+#elif SCHEDFLAG == FRR
+#elif SCHEDFLAG == FCFS
+  if ( cur_proc->pid == sched_q_peek() ) {
+    sched_q_dequeue();
+  }
+#elif SCHEDFLAG == CFS
+  //remove_from_sched_array(cur_proc);
+#endif
+  //cur_proc->sched_time = get_current_ticks();
+  return;
+}
+
+void on_state_set_to_zombi(struct proc *cur_proc)
+{
+  
+#if SCHEDFLAG == DEFAULT
+#elif SCHEDFLAG == FRR
+#elif SCHEDFLAG == FCFS
+  if ( cur_proc->pid == sched_q_peek() ) {
+    sched_q_dequeue();
+  }
+#elif SCHEDFLAG == CFS
+  //remove_from_sched_array(cur_proc);
+#endif
+  //cur_proc->sched_time = get_current_ticks();
+  return;
+}
+
+
+void on_state_set_to_running(struct proc *cur_proc)
+{ 
+#if SCHEDFLAG == DEFAULT
+#elif SCHEDFLAG == FRR
+#elif SCHEDFLAG == FCFS
+#elif SCHEDFLAG == CFS
+#endif
+  //cur_proc->sched_time = get_current_ticks();
+  return;
+}
+
+
+//----------------QUEUE-----------
+
+void sched_q_enqueue(int pid)
+{
+  //struct runnable_queue_entry *p;
+  if((front==0&&rear==NPROC-1)||(front==rear+1)) {                         //condition for full Queue
+    panic("Queue is overflow\n");
+  }
+  if(front==-1) {
+    front=rear=0;
+  } else {
+    
+    if(rear==NPROC-1) {
+      rear=0;
+    } else {
+      rear++;
+    }
+    
+  }
+  scheduler_queue.queue[rear].pid = pid;
+  //cprintf("%d succ. inserted\n",pid);
+  return;
+}
+int sched_q_dequeue(void)
+{
+  int y;
+  if(front==-1) {
+    cprintf("q is underflow\n");
+    return 0;
+  }
+  y=scheduler_queue.queue[front].pid;
+  if(front==rear) {
+    front=rear=-1;
+  } else {
+    if(front==NPROC-1) {
+      front=0;
+    } else {
+      front++;
+    }
+  }
+  //cprintf("%d succ. deleted\n",y);
+  return y;
+}
+
+void sched_q_display(void)
+{
+  int i;
+  if(front==-1 && rear==-1) {
+    cprintf("q is empty\n");return;
+  }
+  cprintf("elements are :\n");
+  for(i=front;i!=rear;i=(i+1)%NPROC) {
+    cprintf("%d ",scheduler_queue.queue[i]);
+  }
+  cprintf("%d\n",scheduler_queue.queue[rear]);
+  return; 
+}
+int sched_q_peek(void)
+{
+  int y;
+  y=scheduler_queue.queue[front].pid;
+  //cprintf("%d peeked (not deleted)\n",y);
+  return y;
+}
+
+//------------ CFS methods -----------
+/*
+void remove_from_sched_array(struct proc *cur_proc)
+{
+  struct runnable_queue_entry *s_entry;
+  
+  for(s_entry = scheduler_queue.queue; s_entry < &scheduler_queue.queue[NPROC]; s_entry++){
+    if ( 1 == s_entry->valid_entry) {
+      if(cur_proc->pid == s_entry->pid) {
+	cprintf("removing: %d\n", cur_proc->pid);
+	s_entry->valid_entry = 0;
+	s_entry->pid         = 0;
+	s_entry->vruntime    = 0xFFFFFFFF;
+      }
+    }
+  }
+}*/
+/*
+void add_to_sched_array(struct proc *cur_proc)
+{
+  struct runnable_queue_entry *s_entry;
+  
+  for(s_entry = scheduler_queue.queue; s_entry < &scheduler_queue.queue[NPROC]; s_entry++){
+    if ( 1 == s_entry->valid_entry) {
+      if(cur_proc->pid == s_entry->pid) {
+	return ;
+      }
+    }
+  }
+  
+  for(s_entry = scheduler_queue.queue; s_entry < &scheduler_queue.queue[NPROC]; s_entry++){
+    if ( 0 == s_entry->valid_entry) {
+      cprintf("adding: %d\n", cur_proc->pid);
+      s_entry->valid_entry = 1;
+      s_entry->pid         = cur_proc->pid;
+      s_entry->vruntime    = (cur_proc->rutime * cur_proc->priority);
+    }
+  }
+}*/
+/*
+int sched_array_get_min_vruntime_pid(void)
+{
+  struct runnable_queue_entry *s_entry;
+  uint min_vruntime = 0xFFFFFFFF;
+  int min_pid = 0;
+  
+  for(s_entry = scheduler_queue.queue; s_entry < &scheduler_queue.queue[NPROC]; s_entry++){
+    if ( min_vruntime > s_entry->vruntime) {
+      min_vruntime = s_entry->vruntime;
+      min_pid      = s_entry->pid;
+    }
+  }
+  return min_pid;
+}*/
+/*
+void sched_array_display_valid_entries(void)
+{
+  int i = 0;
+  struct runnable_queue_entry *s_entry;
+  cprintf("elements are :\n");
+  for(s_entry = scheduler_queue.queue; s_entry < &scheduler_queue.queue[NPROC]; s_entry++){
+    cprintf("%d: ", i);
+    i +=1;
+    if ( 1 == s_entry->valid_entry) {
+      cprintf("%d\t", s_entry->pid); 
+    }
+  }
+  cprintf("\n");
+  for(s_entry = scheduler_queue.queue; s_entry < &scheduler_queue.queue[NPROC]; s_entry++){
+    if ( 1 == s_entry->valid_entry) {
+      cprintf("%d\t", s_entry->vruntime); 
+    }
+  }
+  cprintf("\n");
+  return;
+}
+*/
diff --git a/proc.h b/proc.h
index 3b9c3ac..6e6b95a 100644
--- a/proc.h
+++ b/proc.h
@@ -1,3 +1,6 @@
+#include "job.h"
+//#include "scheduler_cir_queue.h"
+
 // Segments in proc->gdt.
 #define NSEGS     7
 
@@ -66,6 +69,22 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int exitStatus;
+  struct job *job;
+  uint ctime;
+  uint ttime;
+  uint stime;
+  uint retime;
+  uint rutime;
+  uint sched_time;
+  uint priority;
+};
+
+
+struct runnable_queue_entry {
+  int pid;
+  uint vruntime;
+  int valid_entry;
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/read.c b/read.c
new file mode 100644
index 0000000..bcca674
--- /dev/null
+++ b/read.c
@@ -0,0 +1,16 @@
+#include "types.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+  char c = 0;
+  
+  read(0, &c, 1);
+  while ( c != 'q' ) {
+    printf(1, "%c", c);
+    read(0, &c, 1);
+  }
+
+  return 0;
+}
\ No newline at end of file
diff --git a/rm.c b/rm.c
index 4fd33c8..0f04291 100644
--- a/rm.c
+++ b/rm.c
@@ -9,7 +9,7 @@ main(int argc, char *argv[])
 
   if(argc < 2){
     printf(2, "Usage: rm files...\n");
-    exit();
+    exit(EXIT_STATUS_ERR);
   }
 
   for(i = 1; i < argc; i++){
@@ -19,5 +19,5 @@ main(int argc, char *argv[])
     }
   }
 
-  exit();
+  exit(EXIT_STATUS_OK);
 }
diff --git a/sanity.c b/sanity.c
new file mode 100644
index 0000000..1f01ea1
--- /dev/null
+++ b/sanity.c
@@ -0,0 +1,60 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int 
+main(int argc, char *argv[])
+{
+
+  int numOfProcs = 20,i,status, wtime, rtime, iotime, pid;
+  int initial_ticks = 0;
+  long j,dummy;
+  double temp = 0.5;
+  int avgW=0, avgR=0, avgTurnaroundTime=0;
+  
+  set_priority(P_HIGH);
+  
+  for (i = 0 ; i < numOfProcs ; i++ ) {
+    if (fork() == 0) {
+      
+      set_priority(((i % 3) + 1) * P_HIGH);
+      
+      initial_ticks = uptime();
+      // Check if this is 30 ticks
+      for (j = 1 ; ; j++) {
+	 dummy = temp * 2;
+	 dummy = dummy;
+	 temp++;
+	 temp--;
+	 if ( initial_ticks + 30 < uptime() ){
+	   break;
+	 }
+      }
+      
+      exit(getpid());
+      printf(1, "Should never get here\n");
+      break;
+    }
+  }
+  
+  for (i = 0 ; i < numOfProcs; i++) {
+     pid = wait_stat(&status, &wtime, &rtime, &iotime);
+     
+     if (pid != status) {
+       printf(3,"Bad status -%d for process with id %d\n", status, pid);
+     }
+     
+     printf(1, "Pid:%d, priority: %d) Wait Time = %d, Running Time = %d, Turnaround Time = %d.\n", status, ((i % 3) + 1) * P_HIGH, wtime, rtime, (wtime + rtime + iotime));
+     avgW += wtime;
+     avgR += rtime;
+     avgTurnaroundTime += (wtime + rtime + iotime);
+  }
+  
+  avgW = avgW / numOfProcs;
+  avgR = avgR / numOfProcs;
+  avgTurnaroundTime = avgTurnaroundTime / numOfProcs;
+  
+  printf(1,"Averages - Wait=%d, Running=%d, Turnaround=%d .\n", avgW, avgR, avgTurnaroundTime);
+  
+  exit(EXIT_STATUS_OK);
+}
\ No newline at end of file
diff --git a/scheduler_CFS.c b/scheduler_CFS.c
new file mode 100644
index 0000000..1687c60
--- /dev/null
+++ b/scheduler_CFS.c
@@ -0,0 +1,52 @@
+void scheduler(void)
+{
+  struct proc *p;
+  struct proc *chosen_p = NULL;
+    
+  //cprintf("LOADED SCHEDFLAG == CFS\n");
+  
+  for(;;){
+    // Enable interrupts on this processor.
+    sti();
+
+    // Loop over process table looking for process to run.
+    //cprintf("test1111\n");
+    acquire(&ptable.lock);
+    //cprintf("test2222\n");
+    
+    chosen_p = NULL;
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      //cprintf("process, running_time: %d sleeping_time: %d ready_time_time: %d\n", p->rutime, p->stime,p->retime);
+        if(p->state != RUNNABLE)
+            continue;
+	//cprintf("RUNNABLE process, pid:%d      pri: %d  running_time: %d   vruntime: %d\n", p->pid, p->priority, p->rutime, (p->priority *p->rutime));
+	if( NULL == chosen_p ) {
+	  chosen_p = p;
+	  continue;
+	}
+	
+	if( (p->priority * p->rutime) <  (chosen_p->priority * chosen_p->rutime) ){
+	  chosen_p = p;
+	}	
+    }
+    
+    if (chosen_p != NULL) {
+      //cprintf("pid: %d WON!\n", chosen_p->pid );
+        // Switch to chosen process.  It is the process's job
+        // to release ptable.lock and then reacquire it
+        // before jumping back to us.
+        proc = chosen_p;
+        switchuvm(chosen_p);
+        chosen_p->state = RUNNING;
+        on_state_set_to_running(chosen_p);
+        swtch(&cpu->scheduler, proc->context);
+        switchkvm();
+
+        // Process is done running for now.
+        // It should have changed its chosen_p->state before coming back.
+        proc = 0;
+        //cprintf("LOOP %d !\n", chosen_p->pid);
+      }
+    release(&ptable.lock);
+  }
+}
\ No newline at end of file
diff --git a/scheduler_DEFAULT.c b/scheduler_DEFAULT.c
new file mode 100644
index 0000000..abd1163
--- /dev/null
+++ b/scheduler_DEFAULT.c
@@ -0,0 +1,37 @@
+void scheduler(void)
+{
+  struct proc *p;
+  
+  //cprintf("LOADED SCHEDFLAG == DEFAULT\n");
+  
+  for(;;){
+    // Enable interrupts on this processor.
+    sti();
+
+    // Loop over process table looking for process to run.
+    //cprintf("test1111\n");
+    acquire(&ptable.lock);
+    //cprintf("test2222\n");
+    
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+        if(p->state != RUNNABLE)
+            continue;
+	
+        // Switch to chosen process.  It is the process's job
+        // to release ptable.lock and then reacquire it
+        // before jumping back to us.
+        proc = p;
+        switchuvm(p);
+        p->state = RUNNING;
+        on_state_set_to_running(p);
+        swtch(&cpu->scheduler, proc->context);
+        switchkvm();
+
+        // Process is done running for now.
+        // It should have changed its p->state before coming back.
+        proc = 0;
+       // cprintf("LOOP %d !\n", p->pid);
+      }
+    release(&ptable.lock);
+  }
+}
diff --git a/scheduler_FCFS.c b/scheduler_FCFS.c
new file mode 100644
index 0000000..d7098a0
--- /dev/null
+++ b/scheduler_FCFS.c
@@ -0,0 +1,52 @@
+void scheduler(void)
+{
+  struct proc *p;
+  int chosen_pid = 0;
+  //cprintf("LOADED SCHEDFLAG == FCFS\n");
+  
+  for(;;){
+    // Enable interrupts on this processor.
+    sti();
+
+    // Loop over process table looking for process to run.
+    acquire(&ptable.lock);
+    
+    
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+        if(p->state != RUNNABLE)
+            continue;
+	
+	/*
+	cprintf("-----------------------------\n");
+	sched_q_display();
+	cprintf("-----------------------------\n");
+	*/
+	chosen_pid = sched_q_peek();
+	//cprintf("chosen_pid is - %d\n", chosen_pid);
+	
+	for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+	  if(p->pid != chosen_pid) {
+	    continue;
+	  } else {
+	    break;
+	  }
+	}
+	
+        // Switch to chosen process.  It is the process's job
+        // to release ptable.lock and then reacquire it
+        // before jumping back to us.
+        proc = p;
+        switchuvm(p);
+        p->state = RUNNING;
+        on_state_set_to_running(p);
+        swtch(&cpu->scheduler, proc->context);
+        switchkvm();
+
+        // Process is done running for now.
+        // It should have changed its p->state before coming back.
+        proc = 0;
+        //cprintf("LOOP %d !\n", p->pid);
+      }
+    release(&ptable.lock);
+  }
+}
diff --git a/scheduler_FRR.c b/scheduler_FRR.c
new file mode 100644
index 0000000..0aeab3c
--- /dev/null
+++ b/scheduler_FRR.c
@@ -0,0 +1,52 @@
+void scheduler(void)
+{
+  struct proc *p;
+  int chosen_pid = 0;
+  //cprintf("LOADED SCHEDFLAG == FRR\n");
+  
+  for(;;){
+    // Enable interrupts on this processor.
+    sti();
+
+    // Loop over process table looking for process to run.
+    acquire(&ptable.lock);
+    
+    
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+        if(p->state != RUNNABLE)
+            continue;
+	
+	/*
+	cprintf("-----------------------------\n");
+	sched_q_display();
+	cprintf("-----------------------------\n");
+	*/
+	chosen_pid = sched_q_dequeue();
+	//cprintf("chosen_pid is - %d\n", chosen_pid);
+	
+	for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+	  if(p->pid != chosen_pid) {
+	    continue;
+	  } else {
+	    break;
+	  }
+	}
+	
+        // Switch to chosen process.  It is the process's job
+        // to release ptable.lock and then reacquire it
+        // before jumping back to us.
+        proc = p;
+        switchuvm(p);
+        p->state = RUNNING;
+        on_state_set_to_running(p);
+        swtch(&cpu->scheduler, proc->context);
+        switchkvm();
+
+        // Process is done running for now.
+        // It should have changed its p->state before coming back.
+        proc = 0;
+        //cprintf("LOOP %d !\n", p->pid);
+      }
+    release(&ptable.lock);
+  }
+}
diff --git a/scheduler_cir_queue.c b/scheduler_cir_queue.c
new file mode 100644
index 0000000..85647f9
--- /dev/null
+++ b/scheduler_cir_queue.c
@@ -0,0 +1,81 @@
+#include "scheduler_cir_queue.h"
+
+int front = -1;
+int rear  = -1;
+//int q[MAX_QUEUE_SIZE];
+/*
+void main(void)
+{
+     int c;
+     clrscr();
+     front=rear=-1;
+     do
+     {
+          printf("1:insert\n2:deletion\n3:display\n4:exit\nenter choice:");
+          scanf("%d",&c);
+          switch(c)
+          {
+               case 1:enqueue();break;
+               case 2:dequeue();break;
+               case 3:qdisplay();break;
+               case 4:printf("pgm ends\n");break;
+               default:printf("wrong choice\n");break;
+          }
+     }while(c!=4);
+     getch();
+}*/
+void sched_q_enqueue(int pid)
+{
+  struct runnable_queue_entry *p;
+  if((front==0&&rear==MAX_QUEUE_SIZE-1)||(front==rear+1)) {                         //condition for full Queue
+    panic("Queue is overflow\n");
+  }
+  if(front==-1) {
+    front=rear=0;
+  } else {
+    
+    if(rear==MAX_QUEUE_SIZE-1) {
+      rear=0;
+    } else {
+      rear++;
+    }
+    
+  }
+  scheduler_queue.queue[rear]=pid;
+  //printf("%d succ. inserted\n",pid);
+  return;
+}
+int dequeue(void)
+{
+  int y;
+  if(front==-1) {
+    printf("q is underflow\n");
+    return;
+  }
+  y=scheduler_queue.queue[front];
+  if(front==rear) {
+    front=rear=-1;
+  } else {
+    if(front==MAX_QUEUE_SIZE-1) {
+      front=0;
+    } else {
+      front++;
+    }
+  }
+  //printf("%d succ. deleted\n",y);
+  return;
+}
+
+void qdisplay(void)
+{
+  int i;
+  if(front==rear==-1) {
+    printf("q is empty\n");return;
+  }
+  printf("elements are :\n");
+  for(i=front;i!=rear;i=(i+1)%MAX_QUEUE_SIZE) {
+    printf("%d\n",scheduler_queue.queue[i]);
+  }
+  printf("%d\n",scheduler_queue.queue[rear]);
+  return; 
+}
\ No newline at end of file
diff --git a/scheduler_cir_queue.h b/scheduler_cir_queue.h
new file mode 100644
index 0000000..ebf54eb
--- /dev/null
+++ b/scheduler_cir_queue.h
@@ -0,0 +1,13 @@
+// entry in scheduler queue
+#define MAX_QUEUE_SIZE 64
+
+struct runnable_queue_entry {
+  int pid;
+  //int vruntime;
+  //int valid_entry;
+};
+
+void sched_q_enqueue(int pid);
+int  sched_q_dequeue(void);
+//void sched_q_peek(void);
+void sched_q_display(void);
diff --git a/sh.c b/sh.c
index 16e325b..7dc6d86 100644
--- a/sh.c
+++ b/sh.c
@@ -4,6 +4,11 @@
 #include "user.h"
 #include "fcntl.h"
 
+// @itay - Added to use proc here.
+//#include "param.h"
+//#include "mmu.h"
+//#include "proc.h"
+
 // Parsed command representation
 #define EXEC  1
 #define REDIR 2
@@ -50,7 +55,9 @@ struct backcmd {
 };
 
 int fork1(void);  // Fork but panics on failure.
+int fork1CreateJob(char *command);  // Fork but panics on failure - and creates a job.
 void panic(char*);
+int checkSpecialCommands(char buf[100]);
 struct cmd *parsecmd(char*);
 
 // Execute cmd.  Never returns.
@@ -58,6 +65,7 @@ void
 runcmd(struct cmd *cmd)
 {
   int p[2];
+  int status;
   struct backcmd *bcmd;
   struct execcmd *ecmd;
   struct listcmd *lcmd;
@@ -65,7 +73,7 @@ runcmd(struct cmd *cmd)
   struct redircmd *rcmd;
 
   if(cmd == 0)
-    exit();
+    exit(EXIT_STATUS_OK);
   
   switch(cmd->type){
   default:
@@ -74,7 +82,7 @@ runcmd(struct cmd *cmd)
   case EXEC:
     ecmd = (struct execcmd*)cmd;
     if(ecmd->argv[0] == 0)
-      exit();
+      exit(EXIT_STATUS_ERR);
     exec(ecmd->argv[0], ecmd->argv);
     printf(2, "exec %s failed\n", ecmd->argv[0]);
     break;
@@ -84,7 +92,7 @@ runcmd(struct cmd *cmd)
     close(rcmd->fd);
     if(open(rcmd->file, rcmd->mode) < 0){
       printf(2, "open %s failed\n", rcmd->file);
-      exit();
+      exit(EXIT_STATUS_ERR);
     }
     runcmd(rcmd->cmd);
     break;
@@ -93,7 +101,7 @@ runcmd(struct cmd *cmd)
     lcmd = (struct listcmd*)cmd;
     if(fork1() == 0)
       runcmd(lcmd->left);
-    wait();
+    wait(&status);
     runcmd(lcmd->right);
     break;
 
@@ -117,8 +125,8 @@ runcmd(struct cmd *cmd)
     }
     close(p[0]);
     close(p[1]);
-    wait();
-    wait();
+    wait(&status);
+    wait(&status);
     break;
     
   case BACK:
@@ -127,7 +135,8 @@ runcmd(struct cmd *cmd)
       runcmd(bcmd->cmd);
     break;
   }
-  exit();
+  
+  exit(EXIT_STATUS_OK);
 }
 
 int
@@ -156,31 +165,49 @@ main(void)
   }
   
   // Read and run input commands.
-  while(getcmd(buf, sizeof(buf)) >= 0){
+  while(getcmd(buf, sizeof(buf)) >= 0){    
+    if (checkSpecialCommands(buf) > 0) {
+      continue;
+    }
+    
+    if(fork1CreateJob(buf) == 0) {
+      runcmd(parsecmd(buf));
+    }
+    int status;
+    wait(&status);
+    
+    //printf(2, "Program exited with %d\n", status);
+  }
+  exit(EXIT_STATUS_OK);
+}
+
+int 
+checkSpecialCommands(char buf[100]) {
     if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
       // Clumsy but will have to do for now.
       // Chdir has no effect on the parent if run in the child.
       buf[strlen(buf)-1] = 0;  // chop \n
       if(chdir(buf+3) < 0)
         printf(2, "cannot cd %s\n", buf+3);
-      continue;
+      return 1;
     }
-    if(fork1() == 0)
-      runcmd(parsecmd(buf));
-    wait();
-  }
-  exit();
+    else if (buf[0] == 'j' && buf[1] == 'o' && buf[2] == 'b'  && buf[3] == 's') {
+      jobs();
+      return 1;
+    }
+    
+    return 0;
 }
 
 void
 panic(char *s)
 {
   printf(2, "%s\n", s);
-  exit();
+  exit(EXIT_STATUS_ERR);
 }
 
 int
-fork1(void)
+fork1()
 {
   int pid;
   
@@ -190,6 +217,18 @@ fork1(void)
   return pid;
 }
 
+
+int
+fork1CreateJob(char *commandName)
+{
+  int pid;
+  
+  pid = forkjob(commandName);
+  if(pid == -1)
+    panic("fork");
+  return pid;
+}
+
 //PAGEBREAK!
 // Constructors
 
diff --git a/shced b/shced
new file mode 100644
index 0000000..8ff4fc7
--- /dev/null
+++ b/shced
@@ -0,0 +1,11 @@
+//
+
+#if SCHEDFLAG == DEFAULT
+#define XX 1
+#elif SCHEDFLAG == FRR
+#define XX 2
+#elif SCHEDFLAG == FCFS
+#define XX 3
+#elif SCHEDFLAG == CFS
+#define XX 4
+#endif
\ No newline at end of file
diff --git a/spinlock.c b/spinlock.c
index a16621c..02f2d31 100644
--- a/spinlock.c
+++ b/spinlock.c
@@ -25,8 +25,10 @@ void
 acquire(struct spinlock *lk)
 {
   pushcli(); // disable interrupts to avoid deadlock.
-  if(holding(lk))
+  if(holding(lk)){
+    cprintf("yes... this is the bug..\n");
     panic("acquire");
+  }
 
   // The xchg is atomic.
   // It also serializes, so that reads after acquire are not
diff --git a/stat.h b/stat.h
index 8a80933..b103efe 100644
--- a/stat.h
+++ b/stat.h
@@ -9,3 +9,4 @@ struct stat {
   short nlink; // Number of links to file
   uint size;   // Size of file in bytes
 };
+
diff --git a/stressfs.c b/stressfs.c
index 6369400..bc18b5f 100644
--- a/stressfs.c
+++ b/stressfs.c
@@ -43,7 +43,7 @@ main(int argc, char *argv[])
     read(fd, data, sizeof(data));
   close(fd);
 
-  wait();
+  wait(NULL);
   
-  exit();
+  exit(EXIT_STATUS_OK);
 }
diff --git a/syscall.c b/syscall.c
index 799ebc2..6e10d97 100644
--- a/syscall.c
+++ b/syscall.c
@@ -83,6 +83,7 @@ extern int sys_dup(void);
 extern int sys_exec(void);
 extern int sys_exit(void);
 extern int sys_fork(void);
+extern int sys_forkjob(void);
 extern int sys_fstat(void);
 extern int sys_getpid(void);
 extern int sys_kill(void);
@@ -96,8 +97,13 @@ extern int sys_sbrk(void);
 extern int sys_sleep(void);
 extern int sys_unlink(void);
 extern int sys_wait(void);
+extern int sys_waitpid(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_jobs(void);
+extern int sys_fg(void);
+extern int sys_wait_stat(void);
+extern int sys_set_priority(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -121,6 +127,12 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_waitpid]    sys_waitpid,
+[SYS_forkjob]	sys_forkjob,
+[SYS_jobs]    sys_jobs,
+[SYS_fg]      sys_fg,
+[SYS_wait_stat] sys_wait_stat,
+[SYS_set_priority] sys_set_priority,
 };
 
 void
diff --git a/syscall.h b/syscall.h
index bc5f356..ebe9824 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,10 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_waitpid 22
+// Forks, and creates a new job.
+#define SYS_forkjob 23 
+#define SYS_jobs   24
+#define SYS_fg     25
+#define SYS_wait_stat 26
+#define SYS_set_priority 27
\ No newline at end of file
diff --git a/sysfile.c b/sysfile.c
index 2209f6e..e32f636 100644
--- a/sysfile.c
+++ b/sysfile.c
@@ -401,6 +401,13 @@ sys_exec(void)
   if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
     return -1;
   }
+  
+  // asaf - debugging, set proc->name
+  for ( i = 0; i < strlen(path); i++ ) {
+    proc->name[i] = path[i];
+  }
+  proc->name[i] = 0;
+  
   memset(argv, 0, sizeof(argv));
   for(i=0;; i++){
     if(i >= NELEM(argv))
diff --git a/sysproc.c b/sysproc.c
index 027a5e5..43146d1 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -14,16 +14,47 @@ sys_fork(void)
 }
 
 int
-sys_exit(void)
+sys_forkjob(void)
 {
-  exit();
+  char* command;
+  argptr(0, (char**) &command, sizeof(char*));
+  
+  return forkjob(command);
+}
+
+int
+sys_exit()
+{
+  int status;
+  argint(0, &status);
+  //cprintf("enterted: sys_exit, %d\n", status);
+  exit(status);
   return 0;  // not reached
 }
 
 int
 sys_wait(void)
 {
-  return wait();
+  int* status;
+  argptr(0, (char**) &status, sizeof(int*));
+  return wait(status);
+}
+
+
+int
+sys_waitpid(void)
+{
+  int 	pid;
+  int* 	status;
+  int 	options;
+  
+  argint(0, &pid);
+  argptr(1, (char**) &status, sizeof(int*));
+  argint(2, &options);
+  
+  cprintf("inside sys_waitpid => waiting for pid = %d, options = %d\n", pid, options );
+  
+  return waitpid(pid, status, options);
 }
 
 int
@@ -89,3 +120,47 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+int sys_jobs(void) {
+  jobs();
+   return 3;
+}
+
+int sys_fg(void) {
+ 
+  int jid;
+  argint(0, &jid);
+  fg(jid);
+  
+  return 1;
+}
+
+int sys_wait_stat(void) {
+ 
+  int *status, *wtime, *rtime, *iotime;
+ 
+  argptr(0, (char**) &status, sizeof(int*));
+  argptr(1, (char**) &wtime, sizeof(int*));
+  argptr(2, (char**) &rtime, sizeof(int*));
+  argptr(3, (char**) &iotime, sizeof(int*));
+  
+  wait_stat(status, wtime, rtime, iotime);
+  
+  return 1;
+}
+
+int sys_set_priority(void) {
+    int priority;
+    argint(0, &priority);
+    
+    if (priority != P_HIGH && priority != P_MED && priority != P_LOW) {
+      cprintf("Cannot set priority %d, please use one of the given priorities\n", priority); 
+    }
+    else {
+      proc->priority = priority;
+    }
+    
+    
+    
+    return 1;
+}
diff --git a/t1.c b/t1.c
new file mode 100644
index 0000000..2ec5a5d
--- /dev/null
+++ b/t1.c
@@ -0,0 +1,18 @@
+#include "types.h"
+#include "user.h"
+
+int main(int argc, char *argv[])
+{
+  int i = 0;
+  int j = 0;
+  for ( i = 0; i < 1000000; i++ ) {
+    //for (;;){
+    
+    j=1;
+    j = j;
+    //printf(1, "1: %d",i);
+  }
+  
+  printf(1, "1\n");
+  exit(0);
+}
\ No newline at end of file
diff --git a/t2.c b/t2.c
new file mode 100644
index 0000000..29c5652
--- /dev/null
+++ b/t2.c
@@ -0,0 +1,20 @@
+#include "types.h"
+#include "user.h"
+
+int main(int argc, char *argv[])
+{
+  int i = 0;
+  int j = 0;
+  //for ( i = 0; i < 1000000; i++ ) {
+    for(;;){
+      for ( i = 0; i < 1000000; i++ ) {
+	i = i;
+      }
+      //sleep(1);
+    j=2;
+    j = j;
+    //printf(1, "2: %d",i);
+  }
+  printf(1, "2\n");
+  exit(0);
+}
\ No newline at end of file
diff --git a/t3.c b/t3.c
new file mode 100644
index 0000000..3e40630
--- /dev/null
+++ b/t3.c
@@ -0,0 +1,20 @@
+#include "types.h"
+#include "user.h"
+
+int main(int argc, char *argv[])
+{
+  int i = 0;
+  int j = 0;
+  //for ( i = 0; i < 1000000; i++ ) {
+    for(;;){
+      for ( i = 0; i < 1000000; i++ ) {
+	i = i;
+      }
+      sleep(1);
+    j=2;
+    j = j;
+    //printf(1, "2: %d",i);
+  }
+  printf(1, "2\n");
+  exit(0);
+}
\ No newline at end of file
diff --git a/trap.c b/trap.c
index 3f80145..87d78e9 100644
--- a/trap.c
+++ b/trap.c
@@ -8,6 +8,11 @@
 #include "traps.h"
 #include "spinlock.h"
 
+#define DEFAULT 1
+#define FRR 2
+#define FCFS 3
+#define CFS 4
+
 // Interrupt descriptor table (shared by all CPUs).
 struct gatedesc idt[256];
 extern uint vectors[];  // in vectors.S: array of 256 entry pointers
@@ -38,11 +43,11 @@ trap(struct trapframe *tf)
 {
   if(tf->trapno == T_SYSCALL){
     if(proc->killed)
-      exit();
+      exit(EXIT_STATUS_KILLED);
     proc->tf = tf;
     syscall();
     if(proc->killed)
-      exit();
+      exit(EXIT_STATUS_KILLED);
     return;
   }
 
@@ -51,6 +56,7 @@ trap(struct trapframe *tf)
     if(cpu->id == 0){
       acquire(&tickslock);
       ticks++;
+      update_counters();
       wakeup(&ticks);
       release(&tickslock);
     }
@@ -98,14 +104,21 @@ trap(struct trapframe *tf)
   // (If it is still executing in the kernel, let it keep running 
   // until it gets to the regular system call return.)
   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
-    exit();
+    exit(EXIT_STATUS_KILLED);
 
   // Force process to give up CPU on clock tick.
   // If interrupts were on while locks held, would need to check nlock.
-  if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
+  if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER && ((ticks % QUANTA) == 0)) {
+    #if SCHEDFLAG == FCFS
+    //cprintf("trap.c_FCFS - current process: %d\n", proc->pid);
+    ;
+    #else
+    //cprintf("trap.c_yield_ else");
     yield();
+    #endif
+  }
 
   // Check if the process has been killed since we yielded
   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
-    exit();
+    exit(EXIT_STATUS_KILLED);
 }
diff --git a/types.h b/types.h
index e4adf64..7f9569d 100644
--- a/types.h
+++ b/types.h
@@ -2,3 +2,22 @@ typedef unsigned int   uint;
 typedef unsigned short ushort;
 typedef unsigned char  uchar;
 typedef uint pde_t;
+
+#define EXIT_STATUS_OK		111
+#define EXIT_STATUS_KILLED	222
+#define EXIT_STATUS_ERR		333
+
+#ifndef NULL
+#define NULL			0
+#endif 
+
+#define BLOCKING 	100
+#define NON_BLOCKING 	101
+
+#define TRUE 		1
+#define FALSE 		0
+
+#define P_UNDEF	0
+#define P_HIGH	1
+#define P_MED	2
+#define P_LOW	3
\ No newline at end of file
diff --git a/user.h b/user.h
index f45b8d5..5ecaae4 100644
--- a/user.h
+++ b/user.h
@@ -3,8 +3,10 @@ struct rtcdate;
 
 // system calls
 int fork(void);
-int exit(void) __attribute__((noreturn));
-int wait(void);
+int forkjob(char *command);
+int exit(int status) __attribute__((noreturn));
+int wait(int *status);
+int waitpid(int pid, int *status, int options);
 int pipe(int*);
 int write(int, void*, int);
 int read(int, void*, int);
@@ -23,6 +25,10 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int jobs(void);
+int fg(int jid);
+int wait_stat(int *status, int *wtime, int *rtime, int *iotime);
+int set_priority(int priority);
 
 // ulib.c
 int stat(char*, struct stat*);
diff --git a/usertests.c b/usertests.c
index 22a7bfb..e69de29 100644
--- a/usertests.c
+++ b/usertests.c
@@ -1,1757 +0,0 @@
-#include "param.h"
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-#include "fs.h"
-#include "fcntl.h"
-#include "syscall.h"
-#include "traps.h"
-#include "memlayout.h"
-
-char buf[8192];
-char name[3];
-char *echoargv[] = { "echo", "ALL", "TESTS", "PASSED", 0 };
-int stdout = 1;
-
-// does chdir() call iput(p->cwd) in a transaction?
-void
-iputtest(void)
-{
-  printf(stdout, "iput test\n");
-
-  if(mkdir("iputdir") < 0){
-    printf(stdout, "mkdir failed\n");
-    exit();
-  }
-  if(chdir("iputdir") < 0){
-    printf(stdout, "chdir iputdir failed\n");
-    exit();
-  }
-  if(unlink("../iputdir") < 0){
-    printf(stdout, "unlink ../iputdir failed\n");
-    exit();
-  }
-  if(chdir("/") < 0){
-    printf(stdout, "chdir / failed\n");
-    exit();
-  }
-  printf(stdout, "iput test ok\n");
-}
-
-// does exit() call iput(p->cwd) in a transaction?
-void
-exitiputtest(void)
-{
-  int pid;
-
-  printf(stdout, "exitiput test\n");
-
-  pid = fork();
-  if(pid < 0){
-    printf(stdout, "fork failed\n");
-    exit();
-  }
-  if(pid == 0){
-    if(mkdir("iputdir") < 0){
-      printf(stdout, "mkdir failed\n");
-      exit();
-    }
-    if(chdir("iputdir") < 0){
-      printf(stdout, "child chdir failed\n");
-      exit();
-    }
-    if(unlink("../iputdir") < 0){
-      printf(stdout, "unlink ../iputdir failed\n");
-      exit();
-    }
-    exit();
-  }
-  wait();
-  printf(stdout, "exitiput test ok\n");
-}
-
-// does the error path in open() for attempt to write a
-// directory call iput() in a transaction?
-// needs a hacked kernel that pauses just after the namei()
-// call in sys_open():
-//    if((ip = namei(path)) == 0)
-//      return -1;
-//    {
-//      int i;
-//      for(i = 0; i < 10000; i++)
-//        yield();
-//    }
-void
-openiputtest(void)
-{
-  int pid;
-
-  printf(stdout, "openiput test\n");
-  if(mkdir("oidir") < 0){
-    printf(stdout, "mkdir oidir failed\n");
-    exit();
-  }
-  pid = fork();
-  if(pid < 0){
-    printf(stdout, "fork failed\n");
-    exit();
-  }
-  if(pid == 0){
-    int fd = open("oidir", O_RDWR);
-    if(fd >= 0){
-      printf(stdout, "open directory for write succeeded\n");
-      exit();
-    }
-    exit();
-  }
-  sleep(1);
-  if(unlink("oidir") != 0){
-    printf(stdout, "unlink failed\n");
-    exit();
-  }
-  wait();
-  printf(stdout, "openiput test ok\n");
-}
-
-// simple file system tests
-
-void
-opentest(void)
-{
-  int fd;
-
-  printf(stdout, "open test\n");
-  fd = open("echo", 0);
-  if(fd < 0){
-    printf(stdout, "open echo failed!\n");
-    exit();
-  }
-  close(fd);
-  fd = open("doesnotexist", 0);
-  if(fd >= 0){
-    printf(stdout, "open doesnotexist succeeded!\n");
-    exit();
-  }
-  printf(stdout, "open test ok\n");
-}
-
-void
-writetest(void)
-{
-  int fd;
-  int i;
-
-  printf(stdout, "small file test\n");
-  fd = open("small", O_CREATE|O_RDWR);
-  if(fd >= 0){
-    printf(stdout, "creat small succeeded; ok\n");
-  } else {
-    printf(stdout, "error: creat small failed!\n");
-    exit();
-  }
-  for(i = 0; i < 100; i++){
-    if(write(fd, "aaaaaaaaaa", 10) != 10){
-      printf(stdout, "error: write aa %d new file failed\n", i);
-      exit();
-    }
-    if(write(fd, "bbbbbbbbbb", 10) != 10){
-      printf(stdout, "error: write bb %d new file failed\n", i);
-      exit();
-    }
-  }
-  printf(stdout, "writes ok\n");
-  close(fd);
-  fd = open("small", O_RDONLY);
-  if(fd >= 0){
-    printf(stdout, "open small succeeded ok\n");
-  } else {
-    printf(stdout, "error: open small failed!\n");
-    exit();
-  }
-  i = read(fd, buf, 2000);
-  if(i == 2000){
-    printf(stdout, "read succeeded ok\n");
-  } else {
-    printf(stdout, "read failed\n");
-    exit();
-  }
-  close(fd);
-
-  if(unlink("small") < 0){
-    printf(stdout, "unlink small failed\n");
-    exit();
-  }
-  printf(stdout, "small file test ok\n");
-}
-
-void
-writetest1(void)
-{
-  int i, fd, n;
-
-  printf(stdout, "big files test\n");
-
-  fd = open("big", O_CREATE|O_RDWR);
-  if(fd < 0){
-    printf(stdout, "error: creat big failed!\n");
-    exit();
-  }
-
-  for(i = 0; i < MAXFILE; i++){
-    ((int*)buf)[0] = i;
-    if(write(fd, buf, 512) != 512){
-      printf(stdout, "error: write big file failed\n", i);
-      exit();
-    }
-  }
-
-  close(fd);
-
-  fd = open("big", O_RDONLY);
-  if(fd < 0){
-    printf(stdout, "error: open big failed!\n");
-    exit();
-  }
-
-  n = 0;
-  for(;;){
-    i = read(fd, buf, 512);
-    if(i == 0){
-      if(n == MAXFILE - 1){
-        printf(stdout, "read only %d blocks from big", n);
-        exit();
-      }
-      break;
-    } else if(i != 512){
-      printf(stdout, "read failed %d\n", i);
-      exit();
-    }
-    if(((int*)buf)[0] != n){
-      printf(stdout, "read content of block %d is %d\n",
-             n, ((int*)buf)[0]);
-      exit();
-    }
-    n++;
-  }
-  close(fd);
-  if(unlink("big") < 0){
-    printf(stdout, "unlink big failed\n");
-    exit();
-  }
-  printf(stdout, "big files ok\n");
-}
-
-void
-createtest(void)
-{
-  int i, fd;
-
-  printf(stdout, "many creates, followed by unlink test\n");
-
-  name[0] = 'a';
-  name[2] = '\0';
-  for(i = 0; i < 52; i++){
-    name[1] = '0' + i;
-    fd = open(name, O_CREATE|O_RDWR);
-    close(fd);
-  }
-  name[0] = 'a';
-  name[2] = '\0';
-  for(i = 0; i < 52; i++){
-    name[1] = '0' + i;
-    unlink(name);
-  }
-  printf(stdout, "many creates, followed by unlink; ok\n");
-}
-
-void dirtest(void)
-{
-  printf(stdout, "mkdir test\n");
-
-  if(mkdir("dir0") < 0){
-    printf(stdout, "mkdir failed\n");
-    exit();
-  }
-
-  if(chdir("dir0") < 0){
-    printf(stdout, "chdir dir0 failed\n");
-    exit();
-  }
-
-  if(chdir("..") < 0){
-    printf(stdout, "chdir .. failed\n");
-    exit();
-  }
-
-  if(unlink("dir0") < 0){
-    printf(stdout, "unlink dir0 failed\n");
-    exit();
-  }
-  printf(stdout, "mkdir test ok\n");
-}
-
-void
-exectest(void)
-{
-  printf(stdout, "exec test\n");
-  if(exec("echo", echoargv) < 0){
-    printf(stdout, "exec echo failed\n");
-    exit();
-  }
-}
-
-// simple fork and pipe read/write
-
-void
-pipe1(void)
-{
-  int fds[2], pid;
-  int seq, i, n, cc, total;
-
-  if(pipe(fds) != 0){
-    printf(1, "pipe() failed\n");
-    exit();
-  }
-  pid = fork();
-  seq = 0;
-  if(pid == 0){
-    close(fds[0]);
-    for(n = 0; n < 5; n++){
-      for(i = 0; i < 1033; i++)
-        buf[i] = seq++;
-      if(write(fds[1], buf, 1033) != 1033){
-        printf(1, "pipe1 oops 1\n");
-        exit();
-      }
-    }
-    exit();
-  } else if(pid > 0){
-    close(fds[1]);
-    total = 0;
-    cc = 1;
-    while((n = read(fds[0], buf, cc)) > 0){
-      for(i = 0; i < n; i++){
-        if((buf[i] & 0xff) != (seq++ & 0xff)){
-          printf(1, "pipe1 oops 2\n");
-          return;
-        }
-      }
-      total += n;
-      cc = cc * 2;
-      if(cc > sizeof(buf))
-        cc = sizeof(buf);
-    }
-    if(total != 5 * 1033){
-      printf(1, "pipe1 oops 3 total %d\n", total);
-      exit();
-    }
-    close(fds[0]);
-    wait();
-  } else {
-    printf(1, "fork() failed\n");
-    exit();
-  }
-  printf(1, "pipe1 ok\n");
-}
-
-// meant to be run w/ at most two CPUs
-void
-preempt(void)
-{
-  int pid1, pid2, pid3;
-  int pfds[2];
-
-  printf(1, "preempt: ");
-  pid1 = fork();
-  if(pid1 == 0)
-    for(;;)
-      ;
-
-  pid2 = fork();
-  if(pid2 == 0)
-    for(;;)
-      ;
-
-  pipe(pfds);
-  pid3 = fork();
-  if(pid3 == 0){
-    close(pfds[0]);
-    if(write(pfds[1], "x", 1) != 1)
-      printf(1, "preempt write error");
-    close(pfds[1]);
-    for(;;)
-      ;
-  }
-
-  close(pfds[1]);
-  if(read(pfds[0], buf, sizeof(buf)) != 1){
-    printf(1, "preempt read error");
-    return;
-  }
-  close(pfds[0]);
-  printf(1, "kill... ");
-  kill(pid1);
-  kill(pid2);
-  kill(pid3);
-  printf(1, "wait... ");
-  wait();
-  wait();
-  wait();
-  printf(1, "preempt ok\n");
-}
-
-// try to find any races between exit and wait
-void
-exitwait(void)
-{
-  int i, pid;
-
-  for(i = 0; i < 100; i++){
-    pid = fork();
-    if(pid < 0){
-      printf(1, "fork failed\n");
-      return;
-    }
-    if(pid){
-      if(wait() != pid){
-        printf(1, "wait wrong pid\n");
-        return;
-      }
-    } else {
-      exit();
-    }
-  }
-  printf(1, "exitwait ok\n");
-}
-
-void
-mem(void)
-{
-  void *m1, *m2;
-  int pid, ppid;
-
-  printf(1, "mem test\n");
-  ppid = getpid();
-  if((pid = fork()) == 0){
-    m1 = 0;
-    while((m2 = malloc(10001)) != 0){
-      *(char**)m2 = m1;
-      m1 = m2;
-    }
-    while(m1){
-      m2 = *(char**)m1;
-      free(m1);
-      m1 = m2;
-    }
-    m1 = malloc(1024*20);
-    if(m1 == 0){
-      printf(1, "couldn't allocate mem?!!\n");
-      kill(ppid);
-      exit();
-    }
-    free(m1);
-    printf(1, "mem ok\n");
-    exit();
-  } else {
-    wait();
-  }
-}
-
-// More file system tests
-
-// two processes write to the same file descriptor
-// is the offset shared? does inode locking work?
-void
-sharedfd(void)
-{
-  int fd, pid, i, n, nc, np;
-  char buf[10];
-
-  printf(1, "sharedfd test\n");
-
-  unlink("sharedfd");
-  fd = open("sharedfd", O_CREATE|O_RDWR);
-  if(fd < 0){
-    printf(1, "fstests: cannot open sharedfd for writing");
-    return;
-  }
-  pid = fork();
-  memset(buf, pid==0?'c':'p', sizeof(buf));
-  for(i = 0; i < 1000; i++){
-    if(write(fd, buf, sizeof(buf)) != sizeof(buf)){
-      printf(1, "fstests: write sharedfd failed\n");
-      break;
-    }
-  }
-  if(pid == 0)
-    exit();
-  else
-    wait();
-  close(fd);
-  fd = open("sharedfd", 0);
-  if(fd < 0){
-    printf(1, "fstests: cannot open sharedfd for reading\n");
-    return;
-  }
-  nc = np = 0;
-  while((n = read(fd, buf, sizeof(buf))) > 0){
-    for(i = 0; i < sizeof(buf); i++){
-      if(buf[i] == 'c')
-        nc++;
-      if(buf[i] == 'p')
-        np++;
-    }
-  }
-  close(fd);
-  unlink("sharedfd");
-  if(nc == 10000 && np == 10000){
-    printf(1, "sharedfd ok\n");
-  } else {
-    printf(1, "sharedfd oops %d %d\n", nc, np);
-    exit();
-  }
-}
-
-// four processes write different files at the same
-// time, to test block allocation.
-void
-fourfiles(void)
-{
-  int fd, pid, i, j, n, total, pi;
-  char *names[] = { "f0", "f1", "f2", "f3" };
-  char *fname;
-
-  printf(1, "fourfiles test\n");
-
-  for(pi = 0; pi < 4; pi++){
-    fname = names[pi];
-    unlink(fname);
-
-    pid = fork();
-    if(pid < 0){
-      printf(1, "fork failed\n");
-      exit();
-    }
-
-    if(pid == 0){
-      fd = open(fname, O_CREATE | O_RDWR);
-      if(fd < 0){
-        printf(1, "create failed\n");
-        exit();
-      }
-      
-      memset(buf, '0'+pi, 512);
-      for(i = 0; i < 12; i++){
-        if((n = write(fd, buf, 500)) != 500){
-          printf(1, "write failed %d\n", n);
-          exit();
-        }
-      }
-      exit();
-    }
-  }
-
-  for(pi = 0; pi < 4; pi++){
-    wait();
-  }
-
-  for(i = 0; i < 2; i++){
-    fname = names[i];
-    fd = open(fname, 0);
-    total = 0;
-    while((n = read(fd, buf, sizeof(buf))) > 0){
-      for(j = 0; j < n; j++){
-        if(buf[j] != '0'+i){
-          printf(1, "wrong char\n");
-          exit();
-        }
-      }
-      total += n;
-    }
-    close(fd);
-    if(total != 12*500){
-      printf(1, "wrong length %d\n", total);
-      exit();
-    }
-    unlink(fname);
-  }
-
-  printf(1, "fourfiles ok\n");
-}
-
-// four processes create and delete different files in same directory
-void
-createdelete(void)
-{
-  enum { N = 20 };
-  int pid, i, fd, pi;
-  char name[32];
-
-  printf(1, "createdelete test\n");
-
-  for(pi = 0; pi < 4; pi++){
-    pid = fork();
-    if(pid < 0){
-      printf(1, "fork failed\n");
-      exit();
-    }
-
-    if(pid == 0){
-      name[0] = 'p' + pi;
-      name[2] = '\0';
-      for(i = 0; i < N; i++){
-        name[1] = '0' + i;
-        fd = open(name, O_CREATE | O_RDWR);
-        if(fd < 0){
-          printf(1, "create failed\n");
-          exit();
-        }
-        close(fd);
-        if(i > 0 && (i % 2 ) == 0){
-          name[1] = '0' + (i / 2);
-          if(unlink(name) < 0){
-            printf(1, "unlink failed\n");
-            exit();
-          }
-        }
-      }
-      exit();
-    }
-  }
-
-  for(pi = 0; pi < 4; pi++){
-    wait();
-  }
-
-  name[0] = name[1] = name[2] = 0;
-  for(i = 0; i < N; i++){
-    for(pi = 0; pi < 4; pi++){
-      name[0] = 'p' + pi;
-      name[1] = '0' + i;
-      fd = open(name, 0);
-      if((i == 0 || i >= N/2) && fd < 0){
-        printf(1, "oops createdelete %s didn't exist\n", name);
-        exit();
-      } else if((i >= 1 && i < N/2) && fd >= 0){
-        printf(1, "oops createdelete %s did exist\n", name);
-        exit();
-      }
-      if(fd >= 0)
-        close(fd);
-    }
-  }
-
-  for(i = 0; i < N; i++){
-    for(pi = 0; pi < 4; pi++){
-      name[0] = 'p' + i;
-      name[1] = '0' + i;
-      unlink(name);
-    }
-  }
-
-  printf(1, "createdelete ok\n");
-}
-
-// can I unlink a file and still read it?
-void
-unlinkread(void)
-{
-  int fd, fd1;
-
-  printf(1, "unlinkread test\n");
-  fd = open("unlinkread", O_CREATE | O_RDWR);
-  if(fd < 0){
-    printf(1, "create unlinkread failed\n");
-    exit();
-  }
-  write(fd, "hello", 5);
-  close(fd);
-
-  fd = open("unlinkread", O_RDWR);
-  if(fd < 0){
-    printf(1, "open unlinkread failed\n");
-    exit();
-  }
-  if(unlink("unlinkread") != 0){
-    printf(1, "unlink unlinkread failed\n");
-    exit();
-  }
-
-  fd1 = open("unlinkread", O_CREATE | O_RDWR);
-  write(fd1, "yyy", 3);
-  close(fd1);
-
-  if(read(fd, buf, sizeof(buf)) != 5){
-    printf(1, "unlinkread read failed");
-    exit();
-  }
-  if(buf[0] != 'h'){
-    printf(1, "unlinkread wrong data\n");
-    exit();
-  }
-  if(write(fd, buf, 10) != 10){
-    printf(1, "unlinkread write failed\n");
-    exit();
-  }
-  close(fd);
-  unlink("unlinkread");
-  printf(1, "unlinkread ok\n");
-}
-
-void
-linktest(void)
-{
-  int fd;
-
-  printf(1, "linktest\n");
-
-  unlink("lf1");
-  unlink("lf2");
-
-  fd = open("lf1", O_CREATE|O_RDWR);
-  if(fd < 0){
-    printf(1, "create lf1 failed\n");
-    exit();
-  }
-  if(write(fd, "hello", 5) != 5){
-    printf(1, "write lf1 failed\n");
-    exit();
-  }
-  close(fd);
-
-  if(link("lf1", "lf2") < 0){
-    printf(1, "link lf1 lf2 failed\n");
-    exit();
-  }
-  unlink("lf1");
-
-  if(open("lf1", 0) >= 0){
-    printf(1, "unlinked lf1 but it is still there!\n");
-    exit();
-  }
-
-  fd = open("lf2", 0);
-  if(fd < 0){
-    printf(1, "open lf2 failed\n");
-    exit();
-  }
-  if(read(fd, buf, sizeof(buf)) != 5){
-    printf(1, "read lf2 failed\n");
-    exit();
-  }
-  close(fd);
-
-  if(link("lf2", "lf2") >= 0){
-    printf(1, "link lf2 lf2 succeeded! oops\n");
-    exit();
-  }
-
-  unlink("lf2");
-  if(link("lf2", "lf1") >= 0){
-    printf(1, "link non-existant succeeded! oops\n");
-    exit();
-  }
-
-  if(link(".", "lf1") >= 0){
-    printf(1, "link . lf1 succeeded! oops\n");
-    exit();
-  }
-
-  printf(1, "linktest ok\n");
-}
-
-// test concurrent create/link/unlink of the same file
-void
-concreate(void)
-{
-  char file[3];
-  int i, pid, n, fd;
-  char fa[40];
-  struct {
-    ushort inum;
-    char name[14];
-  } de;
-
-  printf(1, "concreate test\n");
-  file[0] = 'C';
-  file[2] = '\0';
-  for(i = 0; i < 40; i++){
-    file[1] = '0' + i;
-    unlink(file);
-    pid = fork();
-    if(pid && (i % 3) == 1){
-      link("C0", file);
-    } else if(pid == 0 && (i % 5) == 1){
-      link("C0", file);
-    } else {
-      fd = open(file, O_CREATE | O_RDWR);
-      if(fd < 0){
-        printf(1, "concreate create %s failed\n", file);
-        exit();
-      }
-      close(fd);
-    }
-    if(pid == 0)
-      exit();
-    else
-      wait();
-  }
-
-  memset(fa, 0, sizeof(fa));
-  fd = open(".", 0);
-  n = 0;
-  while(read(fd, &de, sizeof(de)) > 0){
-    if(de.inum == 0)
-      continue;
-    if(de.name[0] == 'C' && de.name[2] == '\0'){
-      i = de.name[1] - '0';
-      if(i < 0 || i >= sizeof(fa)){
-        printf(1, "concreate weird file %s\n", de.name);
-        exit();
-      }
-      if(fa[i]){
-        printf(1, "concreate duplicate file %s\n", de.name);
-        exit();
-      }
-      fa[i] = 1;
-      n++;
-    }
-  }
-  close(fd);
-
-  if(n != 40){
-    printf(1, "concreate not enough files in directory listing\n");
-    exit();
-  }
-
-  for(i = 0; i < 40; i++){
-    file[1] = '0' + i;
-    pid = fork();
-    if(pid < 0){
-      printf(1, "fork failed\n");
-      exit();
-    }
-    if(((i % 3) == 0 && pid == 0) ||
-       ((i % 3) == 1 && pid != 0)){
-      close(open(file, 0));
-      close(open(file, 0));
-      close(open(file, 0));
-      close(open(file, 0));
-    } else {
-      unlink(file);
-      unlink(file);
-      unlink(file);
-      unlink(file);
-    }
-    if(pid == 0)
-      exit();
-    else
-      wait();
-  }
-
-  printf(1, "concreate ok\n");
-}
-
-// another concurrent link/unlink/create test,
-// to look for deadlocks.
-void
-linkunlink()
-{
-  int pid, i;
-
-  printf(1, "linkunlink test\n");
-
-  unlink("x");
-  pid = fork();
-  if(pid < 0){
-    printf(1, "fork failed\n");
-    exit();
-  }
-
-  unsigned int x = (pid ? 1 : 97);
-  for(i = 0; i < 100; i++){
-    x = x * 1103515245 + 12345;
-    if((x % 3) == 0){
-      close(open("x", O_RDWR | O_CREATE));
-    } else if((x % 3) == 1){
-      link("cat", "x");
-    } else {
-      unlink("x");
-    }
-  }
-
-  if(pid)
-    wait();
-  else 
-    exit();
-
-  printf(1, "linkunlink ok\n");
-}
-
-// directory that uses indirect blocks
-void
-bigdir(void)
-{
-  int i, fd;
-  char name[10];
-
-  printf(1, "bigdir test\n");
-  unlink("bd");
-
-  fd = open("bd", O_CREATE);
-  if(fd < 0){
-    printf(1, "bigdir create failed\n");
-    exit();
-  }
-  close(fd);
-
-  for(i = 0; i < 500; i++){
-    name[0] = 'x';
-    name[1] = '0' + (i / 64);
-    name[2] = '0' + (i % 64);
-    name[3] = '\0';
-    if(link("bd", name) != 0){
-      printf(1, "bigdir link failed\n");
-      exit();
-    }
-  }
-
-  unlink("bd");
-  for(i = 0; i < 500; i++){
-    name[0] = 'x';
-    name[1] = '0' + (i / 64);
-    name[2] = '0' + (i % 64);
-    name[3] = '\0';
-    if(unlink(name) != 0){
-      printf(1, "bigdir unlink failed");
-      exit();
-    }
-  }
-
-  printf(1, "bigdir ok\n");
-}
-
-void
-subdir(void)
-{
-  int fd, cc;
-
-  printf(1, "subdir test\n");
-
-  unlink("ff");
-  if(mkdir("dd") != 0){
-    printf(1, "subdir mkdir dd failed\n");
-    exit();
-  }
-
-  fd = open("dd/ff", O_CREATE | O_RDWR);
-  if(fd < 0){
-    printf(1, "create dd/ff failed\n");
-    exit();
-  }
-  write(fd, "ff", 2);
-  close(fd);
-  
-  if(unlink("dd") >= 0){
-    printf(1, "unlink dd (non-empty dir) succeeded!\n");
-    exit();
-  }
-
-  if(mkdir("/dd/dd") != 0){
-    printf(1, "subdir mkdir dd/dd failed\n");
-    exit();
-  }
-
-  fd = open("dd/dd/ff", O_CREATE | O_RDWR);
-  if(fd < 0){
-    printf(1, "create dd/dd/ff failed\n");
-    exit();
-  }
-  write(fd, "FF", 2);
-  close(fd);
-
-  fd = open("dd/dd/../ff", 0);
-  if(fd < 0){
-    printf(1, "open dd/dd/../ff failed\n");
-    exit();
-  }
-  cc = read(fd, buf, sizeof(buf));
-  if(cc != 2 || buf[0] != 'f'){
-    printf(1, "dd/dd/../ff wrong content\n");
-    exit();
-  }
-  close(fd);
-
-  if(link("dd/dd/ff", "dd/dd/ffff") != 0){
-    printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
-    exit();
-  }
-
-  if(unlink("dd/dd/ff") != 0){
-    printf(1, "unlink dd/dd/ff failed\n");
-    exit();
-  }
-  if(open("dd/dd/ff", O_RDONLY) >= 0){
-    printf(1, "open (unlinked) dd/dd/ff succeeded\n");
-    exit();
-  }
-
-  if(chdir("dd") != 0){
-    printf(1, "chdir dd failed\n");
-    exit();
-  }
-  if(chdir("dd/../../dd") != 0){
-    printf(1, "chdir dd/../../dd failed\n");
-    exit();
-  }
-  if(chdir("dd/../../../dd") != 0){
-    printf(1, "chdir dd/../../dd failed\n");
-    exit();
-  }
-  if(chdir("./..") != 0){
-    printf(1, "chdir ./.. failed\n");
-    exit();
-  }
-
-  fd = open("dd/dd/ffff", 0);
-  if(fd < 0){
-    printf(1, "open dd/dd/ffff failed\n");
-    exit();
-  }
-  if(read(fd, buf, sizeof(buf)) != 2){
-    printf(1, "read dd/dd/ffff wrong len\n");
-    exit();
-  }
-  close(fd);
-
-  if(open("dd/dd/ff", O_RDONLY) >= 0){
-    printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
-    exit();
-  }
-
-  if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
-    printf(1, "create dd/ff/ff succeeded!\n");
-    exit();
-  }
-  if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
-    printf(1, "create dd/xx/ff succeeded!\n");
-    exit();
-  }
-  if(open("dd", O_CREATE) >= 0){
-    printf(1, "create dd succeeded!\n");
-    exit();
-  }
-  if(open("dd", O_RDWR) >= 0){
-    printf(1, "open dd rdwr succeeded!\n");
-    exit();
-  }
-  if(open("dd", O_WRONLY) >= 0){
-    printf(1, "open dd wronly succeeded!\n");
-    exit();
-  }
-  if(link("dd/ff/ff", "dd/dd/xx") == 0){
-    printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
-    exit();
-  }
-  if(link("dd/xx/ff", "dd/dd/xx") == 0){
-    printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
-    exit();
-  }
-  if(link("dd/ff", "dd/dd/ffff") == 0){
-    printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
-    exit();
-  }
-  if(mkdir("dd/ff/ff") == 0){
-    printf(1, "mkdir dd/ff/ff succeeded!\n");
-    exit();
-  }
-  if(mkdir("dd/xx/ff") == 0){
-    printf(1, "mkdir dd/xx/ff succeeded!\n");
-    exit();
-  }
-  if(mkdir("dd/dd/ffff") == 0){
-    printf(1, "mkdir dd/dd/ffff succeeded!\n");
-    exit();
-  }
-  if(unlink("dd/xx/ff") == 0){
-    printf(1, "unlink dd/xx/ff succeeded!\n");
-    exit();
-  }
-  if(unlink("dd/ff/ff") == 0){
-    printf(1, "unlink dd/ff/ff succeeded!\n");
-    exit();
-  }
-  if(chdir("dd/ff") == 0){
-    printf(1, "chdir dd/ff succeeded!\n");
-    exit();
-  }
-  if(chdir("dd/xx") == 0){
-    printf(1, "chdir dd/xx succeeded!\n");
-    exit();
-  }
-
-  if(unlink("dd/dd/ffff") != 0){
-    printf(1, "unlink dd/dd/ff failed\n");
-    exit();
-  }
-  if(unlink("dd/ff") != 0){
-    printf(1, "unlink dd/ff failed\n");
-    exit();
-  }
-  if(unlink("dd") == 0){
-    printf(1, "unlink non-empty dd succeeded!\n");
-    exit();
-  }
-  if(unlink("dd/dd") < 0){
-    printf(1, "unlink dd/dd failed\n");
-    exit();
-  }
-  if(unlink("dd") < 0){
-    printf(1, "unlink dd failed\n");
-    exit();
-  }
-
-  printf(1, "subdir ok\n");
-}
-
-// test writes that are larger than the log.
-void
-bigwrite(void)
-{
-  int fd, sz;
-
-  printf(1, "bigwrite test\n");
-
-  unlink("bigwrite");
-  for(sz = 499; sz < 12*512; sz += 471){
-    fd = open("bigwrite", O_CREATE | O_RDWR);
-    if(fd < 0){
-      printf(1, "cannot create bigwrite\n");
-      exit();
-    }
-    int i;
-    for(i = 0; i < 2; i++){
-      int cc = write(fd, buf, sz);
-      if(cc != sz){
-        printf(1, "write(%d) ret %d\n", sz, cc);
-        exit();
-      }
-    }
-    close(fd);
-    unlink("bigwrite");
-  }
-
-  printf(1, "bigwrite ok\n");
-}
-
-void
-bigfile(void)
-{
-  int fd, i, total, cc;
-
-  printf(1, "bigfile test\n");
-
-  unlink("bigfile");
-  fd = open("bigfile", O_CREATE | O_RDWR);
-  if(fd < 0){
-    printf(1, "cannot create bigfile");
-    exit();
-  }
-  for(i = 0; i < 20; i++){
-    memset(buf, i, 600);
-    if(write(fd, buf, 600) != 600){
-      printf(1, "write bigfile failed\n");
-      exit();
-    }
-  }
-  close(fd);
-
-  fd = open("bigfile", 0);
-  if(fd < 0){
-    printf(1, "cannot open bigfile\n");
-    exit();
-  }
-  total = 0;
-  for(i = 0; ; i++){
-    cc = read(fd, buf, 300);
-    if(cc < 0){
-      printf(1, "read bigfile failed\n");
-      exit();
-    }
-    if(cc == 0)
-      break;
-    if(cc != 300){
-      printf(1, "short read bigfile\n");
-      exit();
-    }
-    if(buf[0] != i/2 || buf[299] != i/2){
-      printf(1, "read bigfile wrong data\n");
-      exit();
-    }
-    total += cc;
-  }
-  close(fd);
-  if(total != 20*600){
-    printf(1, "read bigfile wrong total\n");
-    exit();
-  }
-  unlink("bigfile");
-
-  printf(1, "bigfile test ok\n");
-}
-
-void
-fourteen(void)
-{
-  int fd;
-
-  // DIRSIZ is 14.
-  printf(1, "fourteen test\n");
-
-  if(mkdir("12345678901234") != 0){
-    printf(1, "mkdir 12345678901234 failed\n");
-    exit();
-  }
-  if(mkdir("12345678901234/123456789012345") != 0){
-    printf(1, "mkdir 12345678901234/123456789012345 failed\n");
-    exit();
-  }
-  fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
-  if(fd < 0){
-    printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
-    exit();
-  }
-  close(fd);
-  fd = open("12345678901234/12345678901234/12345678901234", 0);
-  if(fd < 0){
-    printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
-    exit();
-  }
-  close(fd);
-
-  if(mkdir("12345678901234/12345678901234") == 0){
-    printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
-    exit();
-  }
-  if(mkdir("123456789012345/12345678901234") == 0){
-    printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
-    exit();
-  }
-
-  printf(1, "fourteen ok\n");
-}
-
-void
-rmdot(void)
-{
-  printf(1, "rmdot test\n");
-  if(mkdir("dots") != 0){
-    printf(1, "mkdir dots failed\n");
-    exit();
-  }
-  if(chdir("dots") != 0){
-    printf(1, "chdir dots failed\n");
-    exit();
-  }
-  if(unlink(".") == 0){
-    printf(1, "rm . worked!\n");
-    exit();
-  }
-  if(unlink("..") == 0){
-    printf(1, "rm .. worked!\n");
-    exit();
-  }
-  if(chdir("/") != 0){
-    printf(1, "chdir / failed\n");
-    exit();
-  }
-  if(unlink("dots/.") == 0){
-    printf(1, "unlink dots/. worked!\n");
-    exit();
-  }
-  if(unlink("dots/..") == 0){
-    printf(1, "unlink dots/.. worked!\n");
-    exit();
-  }
-  if(unlink("dots") != 0){
-    printf(1, "unlink dots failed!\n");
-    exit();
-  }
-  printf(1, "rmdot ok\n");
-}
-
-void
-dirfile(void)
-{
-  int fd;
-
-  printf(1, "dir vs file\n");
-
-  fd = open("dirfile", O_CREATE);
-  if(fd < 0){
-    printf(1, "create dirfile failed\n");
-    exit();
-  }
-  close(fd);
-  if(chdir("dirfile") == 0){
-    printf(1, "chdir dirfile succeeded!\n");
-    exit();
-  }
-  fd = open("dirfile/xx", 0);
-  if(fd >= 0){
-    printf(1, "create dirfile/xx succeeded!\n");
-    exit();
-  }
-  fd = open("dirfile/xx", O_CREATE);
-  if(fd >= 0){
-    printf(1, "create dirfile/xx succeeded!\n");
-    exit();
-  }
-  if(mkdir("dirfile/xx") == 0){
-    printf(1, "mkdir dirfile/xx succeeded!\n");
-    exit();
-  }
-  if(unlink("dirfile/xx") == 0){
-    printf(1, "unlink dirfile/xx succeeded!\n");
-    exit();
-  }
-  if(link("README", "dirfile/xx") == 0){
-    printf(1, "link to dirfile/xx succeeded!\n");
-    exit();
-  }
-  if(unlink("dirfile") != 0){
-    printf(1, "unlink dirfile failed!\n");
-    exit();
-  }
-
-  fd = open(".", O_RDWR);
-  if(fd >= 0){
-    printf(1, "open . for writing succeeded!\n");
-    exit();
-  }
-  fd = open(".", 0);
-  if(write(fd, "x", 1) > 0){
-    printf(1, "write . succeeded!\n");
-    exit();
-  }
-  close(fd);
-
-  printf(1, "dir vs file OK\n");
-}
-
-// test that iput() is called at the end of _namei()
-void
-iref(void)
-{
-  int i, fd;
-
-  printf(1, "empty file name\n");
-
-  // the 50 is NINODE
-  for(i = 0; i < 50 + 1; i++){
-    if(mkdir("irefd") != 0){
-      printf(1, "mkdir irefd failed\n");
-      exit();
-    }
-    if(chdir("irefd") != 0){
-      printf(1, "chdir irefd failed\n");
-      exit();
-    }
-
-    mkdir("");
-    link("README", "");
-    fd = open("", O_CREATE);
-    if(fd >= 0)
-      close(fd);
-    fd = open("xx", O_CREATE);
-    if(fd >= 0)
-      close(fd);
-    unlink("xx");
-  }
-
-  chdir("/");
-  printf(1, "empty file name OK\n");
-}
-
-// test that fork fails gracefully
-// the forktest binary also does this, but it runs out of proc entries first.
-// inside the bigger usertests binary, we run out of memory first.
-void
-forktest(void)
-{
-  int n, pid;
-
-  printf(1, "fork test\n");
-
-  for(n=0; n<1000; n++){
-    pid = fork();
-    if(pid < 0)
-      break;
-    if(pid == 0)
-      exit();
-  }
-  
-  if(n == 1000){
-    printf(1, "fork claimed to work 1000 times!\n");
-    exit();
-  }
-  
-  for(; n > 0; n--){
-    if(wait() < 0){
-      printf(1, "wait stopped early\n");
-      exit();
-    }
-  }
-  
-  if(wait() != -1){
-    printf(1, "wait got too many\n");
-    exit();
-  }
-  
-  printf(1, "fork test OK\n");
-}
-
-void
-sbrktest(void)
-{
-  int fds[2], pid, pids[10], ppid;
-  char *a, *b, *c, *lastaddr, *oldbrk, *p, scratch;
-  uint amt;
-
-  printf(stdout, "sbrk test\n");
-  oldbrk = sbrk(0);
-
-  // can one sbrk() less than a page?
-  a = sbrk(0);
-  int i;
-  for(i = 0; i < 5000; i++){ 
-    b = sbrk(1);
-    if(b != a){
-      printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
-      exit();
-    }
-    *b = 1;
-    a = b + 1;
-  }
-  pid = fork();
-  if(pid < 0){
-    printf(stdout, "sbrk test fork failed\n");
-    exit();
-  }
-  c = sbrk(1);
-  c = sbrk(1);
-  if(c != a + 1){
-    printf(stdout, "sbrk test failed post-fork\n");
-    exit();
-  }
-  if(pid == 0)
-    exit();
-  wait();
-
-  // can one grow address space to something big?
-#define BIG (100*1024*1024)
-  a = sbrk(0);
-  amt = (BIG) - (uint)a;
-  p = sbrk(amt);
-  if (p != a) { 
-    printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
-    exit();
-  }
-  lastaddr = (char*) (BIG-1);
-  *lastaddr = 99;
-
-  // can one de-allocate?
-  a = sbrk(0);
-  c = sbrk(-4096);
-  if(c == (char*)0xffffffff){
-    printf(stdout, "sbrk could not deallocate\n");
-    exit();
-  }
-  c = sbrk(0);
-  if(c != a - 4096){
-    printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
-    exit();
-  }
-
-  // can one re-allocate that page?
-  a = sbrk(0);
-  c = sbrk(4096);
-  if(c != a || sbrk(0) != a + 4096){
-    printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
-    exit();
-  }
-  if(*lastaddr == 99){
-    // should be zero
-    printf(stdout, "sbrk de-allocation didn't really deallocate\n");
-    exit();
-  }
-
-  a = sbrk(0);
-  c = sbrk(-(sbrk(0) - oldbrk));
-  if(c != a){
-    printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
-    exit();
-  }
-  
-  // can we read the kernel's memory?
-  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
-    ppid = getpid();
-    pid = fork();
-    if(pid < 0){
-      printf(stdout, "fork failed\n");
-      exit();
-    }
-    if(pid == 0){
-      printf(stdout, "oops could read %x = %x\n", a, *a);
-      kill(ppid);
-      exit();
-    }
-    wait();
-  }
-
-  // if we run the system out of memory, does it clean up the last
-  // failed allocation?
-  if(pipe(fds) != 0){
-    printf(1, "pipe() failed\n");
-    exit();
-  }
-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
-    if((pids[i] = fork()) == 0){
-      // allocate a lot of memory
-      sbrk(BIG - (uint)sbrk(0));
-      write(fds[1], "x", 1);
-      // sit around until killed
-      for(;;) sleep(1000);
-    }
-    if(pids[i] != -1)
-      read(fds[0], &scratch, 1);
-  }
-  // if those failed allocations freed up the pages they did allocate,
-  // we'll be able to allocate here
-  c = sbrk(4096);
-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
-    if(pids[i] == -1)
-      continue;
-    kill(pids[i]);
-    wait();
-  }
-  if(c == (char*)0xffffffff){
-    printf(stdout, "failed sbrk leaked memory\n");
-    exit();
-  }
-
-  if(sbrk(0) > oldbrk)
-    sbrk(-(sbrk(0) - oldbrk));
-
-  printf(stdout, "sbrk test OK\n");
-}
-
-void
-validateint(int *p)
-{
-  int res;
-  asm("mov %%esp, %%ebx\n\t"
-      "mov %3, %%esp\n\t"
-      "int %2\n\t"
-      "mov %%ebx, %%esp" :
-      "=a" (res) :
-      "a" (SYS_sleep), "n" (T_SYSCALL), "c" (p) :
-      "ebx");
-}
-
-void
-validatetest(void)
-{
-  int hi, pid;
-  uint p;
-
-  printf(stdout, "validate test\n");
-  hi = 1100*1024;
-
-  for(p = 0; p <= (uint)hi; p += 4096){
-    if((pid = fork()) == 0){
-      // try to crash the kernel by passing in a badly placed integer
-      validateint((int*)p);
-      exit();
-    }
-    sleep(0);
-    sleep(0);
-    kill(pid);
-    wait();
-
-    // try to crash the kernel by passing in a bad string pointer
-    if(link("nosuchfile", (char*)p) != -1){
-      printf(stdout, "link should not succeed\n");
-      exit();
-    }
-  }
-
-  printf(stdout, "validate ok\n");
-}
-
-// does unintialized data start out zero?
-char uninit[10000];
-void
-bsstest(void)
-{
-  int i;
-
-  printf(stdout, "bss test\n");
-  for(i = 0; i < sizeof(uninit); i++){
-    if(uninit[i] != '\0'){
-      printf(stdout, "bss test failed\n");
-      exit();
-    }
-  }
-  printf(stdout, "bss test ok\n");
-}
-
-// does exec return an error if the arguments
-// are larger than a page? or does it write
-// below the stack and wreck the instructions/data?
-void
-bigargtest(void)
-{
-  int pid, fd;
-
-  unlink("bigarg-ok");
-  pid = fork();
-  if(pid == 0){
-    static char *args[MAXARG];
-    int i;
-    for(i = 0; i < MAXARG-1; i++)
-      args[i] = "bigargs test: failed\n                                                                                                                                                                                                       ";
-    args[MAXARG-1] = 0;
-    printf(stdout, "bigarg test\n");
-    exec("echo", args);
-    printf(stdout, "bigarg test ok\n");
-    fd = open("bigarg-ok", O_CREATE);
-    close(fd);
-    exit();
-  } else if(pid < 0){
-    printf(stdout, "bigargtest: fork failed\n");
-    exit();
-  }
-  wait();
-  fd = open("bigarg-ok", 0);
-  if(fd < 0){
-    printf(stdout, "bigarg test failed!\n");
-    exit();
-  }
-  close(fd);
-  unlink("bigarg-ok");
-}
-
-// what happens when the file system runs out of blocks?
-// answer: balloc panics, so this test is not useful.
-void
-fsfull()
-{
-  int nfiles;
-  int fsblocks = 0;
-
-  printf(1, "fsfull test\n");
-
-  for(nfiles = 0; ; nfiles++){
-    char name[64];
-    name[0] = 'f';
-    name[1] = '0' + nfiles / 1000;
-    name[2] = '0' + (nfiles % 1000) / 100;
-    name[3] = '0' + (nfiles % 100) / 10;
-    name[4] = '0' + (nfiles % 10);
-    name[5] = '\0';
-    printf(1, "writing %s\n", name);
-    int fd = open(name, O_CREATE|O_RDWR);
-    if(fd < 0){
-      printf(1, "open %s failed\n", name);
-      break;
-    }
-    int total = 0;
-    while(1){
-      int cc = write(fd, buf, 512);
-      if(cc < 512)
-        break;
-      total += cc;
-      fsblocks++;
-    }
-    printf(1, "wrote %d bytes\n", total);
-    close(fd);
-    if(total == 0)
-      break;
-  }
-
-  while(nfiles >= 0){
-    char name[64];
-    name[0] = 'f';
-    name[1] = '0' + nfiles / 1000;
-    name[2] = '0' + (nfiles % 1000) / 100;
-    name[3] = '0' + (nfiles % 100) / 10;
-    name[4] = '0' + (nfiles % 10);
-    name[5] = '\0';
-    unlink(name);
-    nfiles--;
-  }
-
-  printf(1, "fsfull test finished\n");
-}
-
-unsigned long randstate = 1;
-unsigned int
-rand()
-{
-  randstate = randstate * 1664525 + 1013904223;
-  return randstate;
-}
-
-int
-main(int argc, char *argv[])
-{
-  printf(1, "usertests starting\n");
-
-  if(open("usertests.ran", 0) >= 0){
-    printf(1, "already ran user tests -- rebuild fs.img\n");
-    exit();
-  }
-  close(open("usertests.ran", O_CREATE));
-
-  createdelete();
-  linkunlink();
-  concreate();
-  fourfiles();
-  sharedfd();
-
-  bigargtest();
-  bigwrite();
-  bigargtest();
-  bsstest();
-  sbrktest();
-  validatetest();
-
-  opentest();
-  writetest();
-  writetest1();
-  createtest();
-
-  openiputtest();
-  exitiputtest();
-  iputtest();
-
-  mem();
-  pipe1();
-  preempt();
-  exitwait();
-
-  rmdot();
-  fourteen();
-  bigfile();
-  subdir();
-  linktest();
-  unlinkread();
-  dirfile();
-  iref();
-  forktest();
-  bigdir(); // slow
-  exectest();
-
-  exit();
-}
diff --git a/usys.S b/usys.S
index 8bfd8a1..df4ec39 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,9 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(waitpid)
+SYSCALL(forkjob)
+SYSCALL(jobs)
+SYSCALL(fg)
+SYSCALL(wait_stat)
+SYSCALL(set_priority)
\ No newline at end of file
diff --git a/wc.c b/wc.c
index d6a54df..8ecc339 100644
--- a/wc.c
+++ b/wc.c
@@ -27,7 +27,7 @@ wc(int fd, char *name)
   }
   if(n < 0){
     printf(1, "wc: read error\n");
-    exit();
+    exit(EXIT_STATUS_ERR);
   }
   printf(1, "%d %d %d %s\n", l, w, c, name);
 }
@@ -39,16 +39,16 @@ main(int argc, char *argv[])
 
   if(argc <= 1){
     wc(0, "");
-    exit();
+    exit(EXIT_STATUS_OK);
   }
 
   for(i = 1; i < argc; i++){
     if((fd = open(argv[i], 0)) < 0){
       printf(1, "wc: cannot open %s\n", argv[i]);
-      exit();
+      exit(EXIT_STATUS_ERR);
     }
     wc(fd, argv[i]);
     close(fd);
   }
-  exit();
+  exit(EXIT_STATUS_OK);
 }
diff --git a/zombie.c b/zombie.c
index 077c02c..7d5ece0 100644
--- a/zombie.c
+++ b/zombie.c
@@ -10,5 +10,5 @@ main(void)
 {
   if(fork() > 0)
     sleep(5);  // Let child exit before parent.
-  exit();
+  exit(EXIT_STATUS_OK);
 }
-- 
1.8.4.2

